var RowHeightException = /** @class */ (function () {
    function RowHeightException(index, y, height) {
        this.index = index;
        this.y = y;
        this.height = height;
    }
    Object.defineProperty(RowHeightException.prototype, "y2", {
        get: function () {
            return this.y + this.height;
        },
        enumerable: false,
        configurable: true
    });
    return RowHeightException;
}());
/**
 * creates a uniform exception context, i.e no exceptions all rows are of the same height
 * @param {number} numberOfRows
 * @param {number} currentRowHeight
 * @param {number} rowPadding padding between rows
 * @return {IExceptionContext}
 */
export function uniformContext(numberOfRows, rowHeight, rowPadding) {
    if (rowPadding === void 0) { rowPadding = 0; }
    var currentRowHeight = rowHeight + rowPadding;
    var exceptionsLookup = {
        keys: function () { return [].values(); },
        get: function () { return currentRowHeight; },
        has: function () { return false; },
        size: 0,
    };
    return {
        exceptions: [],
        exceptionsLookup: exceptionsLookup,
        totalHeight: numberOfRows * currentRowHeight,
        numberOfRows: numberOfRows,
        defaultRowHeight: currentRowHeight,
        padding: function () { return rowPadding; },
    };
}
/**
 * computes the most frequent value in a given array like
 * @param {} values
 * @return {number}
 */
function mostFrequentValue(values) {
    var lookup = new Map();
    values.forEach(function (value) {
        lookup.set(value, (lookup.get(value) || 0) + 1);
    });
    if (lookup.size === 0) {
        return 20; // default value since it doesn't matter
    }
    // sort desc take first key and asc by the second in case of tie, it is optimized to have exceptions for higher rows less for big rows
    var sorted = Array.from(lookup).sort(function (a, b) {
        if (a[1] !== b[1]) {
            return b[1] - a[1];
        }
        return a[0] - b[0];
    });
    var mostFrequent = sorted[0][0];
    if (mostFrequent === 0) {
        // corner case
        return sorted.length > 1 ? sorted[1][0] : 20; // all empty
    }
    return mostFrequent;
}
/**
 * creates a non uniform context based on the given array like heights
 * @param rowHeights array like to get the heights
 * @param {number} defaultRowHeight if not given the most frequent value will be used
 * @param {number} rowPadding padding between rows
 * @return {IExceptionContext}
 */
export function nonUniformContext(rowHeights, defaultRowHeight, rowPadding) {
    if (defaultRowHeight === void 0) { defaultRowHeight = Number.NaN; }
    if (rowPadding === void 0) { rowPadding = 0; }
    var exceptionsLookup = new Map();
    var exceptions = [];
    var padding = typeof rowPadding === 'function' ? rowPadding : function () { return rowPadding; };
    var actualDefaultRowHeight = defaultRowHeight;
    if (Number.isNaN(actualDefaultRowHeight)) {
        actualDefaultRowHeight = mostFrequentValue(rowHeights);
    }
    actualDefaultRowHeight += padding(-1);
    var prev = -1;
    var acc = 0;
    var totalHeight = 0;
    var numberOfRows = 0;
    rowHeights.forEach(function (height, index) {
        var paddedHeight = height + padding(index);
        totalHeight += paddedHeight;
        numberOfRows += 1;
        if (paddedHeight === actualDefaultRowHeight) {
            // regular
            return;
        }
        exceptionsLookup.set(index, paddedHeight);
        var between = (index - prev - 1) * actualDefaultRowHeight;
        prev = index;
        var y = acc + between;
        acc = y + paddedHeight;
        exceptions.push(new RowHeightException(index, y, paddedHeight));
    });
    return {
        exceptionsLookup: exceptionsLookup,
        exceptions: exceptions,
        totalHeight: totalHeight,
        defaultRowHeight: actualDefaultRowHeight,
        numberOfRows: numberOfRows,
        padding: padding,
    };
}
/**
 * creates a random context with the given constraints
 * @param {number} numberOfRows
 * @param {number} defaultRowHeight
 * @param {number} minRowHeight
 * @param {number} maxRowHeight
 * @param {number} ratio around ratio percent will get a non uniform height
 * @param {number} seed random seed
 * @return {IExceptionContext}
 */
export function randomContext(numberOfRows, defaultRowHeight, minRowHeight, maxRowHeight, ratio, seed) {
    if (minRowHeight === void 0) { minRowHeight = 2; }
    if (maxRowHeight === void 0) { maxRowHeight = defaultRowHeight * 10; }
    if (ratio === void 0) { ratio = 0.2; }
    if (seed === void 0) { seed = Date.now(); }
    var actSeed = seed;
    var random = function () {
        var x = Math.sin(actSeed) * 10000;
        actSeed += 1;
        return x - Math.floor(x);
    };
    var getter = function () {
        var coin = random();
        if (coin < ratio) {
            // non uniform
            return minRowHeight + Math.round(random() * (maxRowHeight - minRowHeight));
        }
        return defaultRowHeight;
    };
    var forEach = function (callback) {
        for (var index = 0; index < numberOfRows; index += 1) {
            callback(getter(), index);
        }
    };
    return nonUniformContext({ forEach: forEach }, defaultRowHeight);
}
/**
 * computes the visible range
 * @param {number} scrollTop top scrolling
 * @param {number} clientHeight visible height
 * @param {number} rowHeight height of a row by default
 * @param {IRowHeightException[]} heightExceptions exceptions of this default height
 * @param {number} numberOfRows the number of rows
 * @return {IVisibleRange} the computed visible range
 */
export function range(scrollTop, clientHeight, rowHeight, heightExceptions, numberOfRows) {
    if (numberOfRows === 0) {
        return { first: 0, last: -1, firstRowPos: 0, endPos: 0 };
    }
    if (numberOfRows === 1) {
        return {
            first: 0,
            last: 0,
            firstRowPos: 0,
            endPos: heightExceptions.length === 0 ? rowHeight : heightExceptions[0].y2,
        };
    }
    var offset = scrollTop;
    var offset2 = offset + clientHeight;
    function indexOf(pos, indexShift) {
        return Math.min(numberOfRows - 1, indexShift + Math.max(0, Math.floor(pos / rowHeight)));
    }
    function calc(offsetShift, indexShift) {
        var shifted = offset - offsetShift;
        var shifted2 = offset2 - offsetShift;
        var first = indexOf(shifted, indexShift);
        var last = indexOf(shifted2, indexShift);
        var firstRowPos = offsetShift + (first - indexShift) * rowHeight;
        var endPos = offsetShift + (last + 1 - indexShift) * rowHeight;
        // if (!isGuess) {
        //  console.log(first, '@', firstRowPos, last, '#', end, offset, offset2, firstRowPos <= offset, offset2 <= end);
        // }
        // console.assert(
        //   !isGuess || !(firstRowPos > offset || (endPos < offset2 && last < numberOfRows - 1)),
        //   'error',
        //   isGuess,
        //   firstRowPos,
        //   endPos,
        //   offset,
        //   offset2,
        //   indexShift,
        //   offsetShift
        // );
        return { first: first, last: last, firstRowPos: firstRowPos, endPos: endPos };
    }
    var r = calc(0, 0);
    if (heightExceptions.length === 0) {
        // uniform
        return r;
    }
    if (r.last < heightExceptions[0].index) {
        // console.log('before the first exception = uniform with no shift');
        // console.log(r.first, '@', r.firstRowPos, r.last, '#', r.end, offset, offset2, r.firstRowPos <= offset, offset2 <= r.end);
        return r;
    }
    if (r.last === heightExceptions[0].index && heightExceptions[0].height > rowHeight) {
        return Object.assign(r, { endPos: heightExceptions[0].y2 });
    }
    // the position where the exceptions ends
    var lastPos = heightExceptions[heightExceptions.length - 1];
    if (offset >= lastPos.y) {
        var rest = calc(lastPos.y2, lastPos.index + 1);
        if (offset < lastPos.y2) {
            // include me
            return Object.assign(rest, {
                first: lastPos.index,
                firstRowPos: lastPos.y,
            });
        }
        return rest;
    }
    // we have some exceptions
    var visible = [];
    var closest = heightExceptions[0]; // closest before not in range
    for (var _i = 0, heightExceptions_1 = heightExceptions; _i < heightExceptions_1.length; _i++) {
        var item = heightExceptions_1[_i];
        var y = item.y, y2 = item.y2;
        if (y >= offset2) {
            break;
        }
        if (y2 <= offset) {
            closest = item;
            continue;
        }
        visible.push(item);
    }
    if (visible.length === 0) {
        // console.log('we are in the between some exceptions and none are visible');
        return calc(closest.y2, closest.index + 1); // skip myself
    }
    {
        // console.log('we show at least one exception');
        var firstException = visible[0];
        var lastException = visible[visible.length - 1];
        var first = Math.max(0, firstException.index - Math.max(0, Math.ceil((firstException.y - offset) / rowHeight)));
        var last = lastException.index;
        if (offset2 >= lastException.y2) {
            last = indexOf(offset2 - lastException.y2, lastException.index + 1);
        }
        var firstRowPos = firstException.y - (firstException.index - first) * rowHeight;
        var endPos = lastException.y2 + (last - lastException.index) * rowHeight;
        // console.log(first, '@', firstRowPos, last, '#', end, offset, offset2, firstRowPos <= offset, offset2 <= end);
        // console.assert(
        //   firstRowPos <= offset && (endPos >= offset2 || last === numberOfRows - 1),
        //   'error',
        //   firstRowPos,
        //   endPos,
        //   offset,
        //   offset2,
        //   firstException,
        //   lastException
        // );
        return { first: first, last: last, firstRowPos: firstRowPos, endPos: endPos };
    }
}
export function frozenDelta(current, target) {
    var currentLength = current.length;
    var targetLength = target.length;
    if (currentLength === 0) {
        return { added: target, removed: [], common: 0 };
    }
    if (targetLength === 0) {
        return { added: [], removed: current, common: 0 };
    }
    if (currentLength === targetLength) {
        // since sorted and left increasing true
        return { added: [], removed: [], common: currentLength };
    }
    var removed = current.slice(Math.min(targetLength, currentLength));
    var added = target.slice(Math.min(targetLength, currentLength));
    return { added: added, removed: removed, common: currentLength - removed.length };
}
export function updateFrozen(old, columns, first) {
    var oldLast = old.length === 0 ? 0 : old[old.length - 1] + 1;
    var added = [];
    var removed = [];
    for (var i = old.length - 1; i >= 0; i -= 1) {
        var index = old[i];
        if (index >= first) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            removed.push(old.pop());
        }
        else {
            // can stop since sorted and it will never happen again
            break;
        }
    }
    // added
    for (var i = oldLast; i < first; i += 1) {
        if (columns[i].frozen) {
            added.push(i);
            old.push(i);
        }
    }
    return { target: old, added: added, removed: removed };
}
//# sourceMappingURL=logic.js.map