import { ABORTED, isAbortAble, isAsyncUpdate } from '../../abortAble';
import { isLoadingCell } from '../../ARowRenderer';
import { clear } from '../../internal';
import { isScrollEventWaiting } from '../../internal/scroll';
import { range, updateFrozen } from '../../logic';
import { EScrollResult } from '../../mixin';
import { cssClass, CSS_CLASS_FROZEN, CSS_CLASS_LOADING, CSS_CLASS_SHIFTED, CSS_CLASS_TD, CSS_CLASS_TH, } from '../../styles';
/**
 * @internal
 */
var ACellAdapter = /** @class */ (function () {
    function ACellAdapter(header, style, tableId, mixinClasses) {
        if (mixinClasses === void 0) { mixinClasses = []; }
        var _this = this;
        this.header = header;
        this.style = style;
        this.tableId = tableId;
        /**
         * pool of cells per column
         * @type {Array}
         */
        this.cellPool = [];
        this.loading = new WeakMap();
        this.visibleColumns = {
            frozen: [],
            first: 0,
            forcedFirst: 0,
            last: -1,
            forcedLast: -1,
        };
        this.visibleFirstColumnPos = 0;
        this.horizontallyShifted = false;
        this.columnAdapter = this.createColumnAdapter();
        this.columnMixins = mixinClasses.map(function (MixinClass) { return new MixinClass(_this.columnAdapter); });
        this.columnFragment = header.ownerDocument.createDocumentFragment();
    }
    ACellAdapter.prototype.leftShift = function () {
        var ctx = this.context;
        var frozen = this.visibleColumns.frozen.reduce(function (a, d) { return a + ctx.columns[d].width + ctx.column.padding(d); }, 0);
        return this.visibleFirstColumnPos - frozen;
    };
    Object.defineProperty(ACellAdapter.prototype, "headerScroller", {
        get: function () {
            return this.header.parentElement;
        },
        enumerable: false,
        configurable: true
    });
    ACellAdapter.prototype.addColumnMixin = function (MixinClass, options) {
        this.columnMixins.push(new MixinClass(this.columnAdapter, options));
    };
    ACellAdapter.prototype.createColumnAdapter = function () {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var that = this;
        var r = {
            visible: this.visibleColumns,
            addAtBeginning: this.addColumnAtStart.bind(this),
            addAtBottom: this.addColumnAtEnd.bind(this),
            removeFromBeginning: this.removeColumnFromStart.bind(this),
            removeFromBottom: this.removeColumnFromEnd.bind(this),
            updateOffset: this.updateColumnOffset.bind(this),
            scroller: this.headerScroller,
            syncFrozen: this.syncFrozen.bind(this),
            isScrollEventWaiting: function () { return isScrollEventWaiting(_this.headerScroller, 'animation'); },
            get visibleFirstRowPos() {
                return that.visibleFirstColumnPos;
            },
            get context() {
                return that.context.column;
            },
            get scrollOffset() {
                return that.lastScrollInfo ? that.lastScrollInfo.left : 0;
            },
            get scrollTotal() {
                return that.lastScrollInfo ? that.lastScrollInfo.width : that.headerScroller.clientWidth;
            },
        };
        return r;
    };
    ACellAdapter.prototype.init = function () {
        var _this = this;
        var context = this.context;
        this.style.update(context.defaultRowHeight - context.padding(-1), context.columns, context.column.padding, 0, this.tableId);
        context.columns.forEach(function () {
            // init pool
            _this.cellPool.push([]);
        });
    };
    ACellAdapter.prototype.onScrolledHorizontally = function (scrollLeft, clientWidth, isGoingRight) {
        var scrollResult = this.onScrolledHorizontallyImpl(scrollLeft, clientWidth);
        for (var _i = 0, _a = this.columnMixins; _i < _a.length; _i++) {
            var mixin = _a[_i];
            mixin.onScrolled(isGoingRight, scrollResult);
        }
        return scrollResult;
    };
    ACellAdapter.prototype.removeColumnFromStart = function (from, to, frozenShift) {
        var _this = this;
        if (frozenShift === void 0) { frozenShift = this.visibleColumns.frozen.length; }
        this.forEachRow(function (row) {
            _this.removeCellFromStart(row, from, to, frozenShift);
        });
        // if (debug) {
        //   this.verifyRows();
        // }
    };
    ACellAdapter.prototype.removeCellFromStart = function (row, from, to, frozenShift) {
        for (var i = from; i <= to; i += 1) {
            var node = (frozenShift === 0 ? row.firstElementChild : row.children[frozenShift]);
            node.remove();
            this.recycleCell(node, i);
        }
        // if (debug) {
        //   verifyRow(row, -1, this.context.columns);
        // }
    };
    ACellAdapter.prototype.removeColumnFromEnd = function (from, to) {
        var _this = this;
        this.forEachRow(function (row) {
            _this.removeCellFromEnd(row, from, to);
        });
        // if (debug) {
        //   this.verifyRows();
        // }
    };
    ACellAdapter.prototype.removeCellFromEnd = function (row, from, to) {
        for (var i = to; i >= from; i -= 1) {
            var node = row.lastElementChild;
            node.remove();
            this.recycleCell(node, i);
        }
        // if (debug) {
        //   verifyRow(row, -1, this.context.columns);
        // }
    };
    ACellAdapter.prototype.removeFrozenCells = function (row, columnIndices, shift) {
        for (var _i = 0, columnIndices_1 = columnIndices; _i < columnIndices_1.length; _i++) {
            var columnIndex = columnIndices_1[_i];
            var node = row.children[shift];
            node.remove();
            this.recycleCell(node, columnIndex);
        }
        // if (debug) {
        //   verifyRow(row, -1, this.context.columns);
        // }
    };
    ACellAdapter.prototype.removeFrozenColumns = function (columnIndices, shift) {
        var _this = this;
        this.forEachRow(function (row) {
            _this.removeFrozenCells(row, columnIndices, shift);
        });
        // if (debug) {
        //   this.verifyRows();
        // }
    };
    ACellAdapter.prototype.removeAllColumns = function (includingFrozen) {
        var _this = this;
        this.forEachRow(function (row) {
            _this.removeAllCells(row, includingFrozen);
        });
        // if (debug) {
        //   this.verifyRows();
        // }
    };
    ACellAdapter.prototype.removeAllCells = function (row, includingFrozen, shift) {
        var _this = this;
        if (shift === void 0) { shift = this.visibleColumns.first; }
        var arr = Array.from(row.children);
        var frozen = this.visibleColumns.frozen;
        clear(row);
        if (includingFrozen || frozen.length === 0) {
            for (var _i = 0, frozen_1 = frozen; _i < frozen_1.length; _i++) {
                var i = frozen_1[_i];
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.recycleCell(arr.shift(), i);
            }
        }
        else {
            // have frozen and keep them, so readd them
            for (var i = 0; i < frozen.length; i += 1) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                row.appendChild(arr.shift());
            }
        }
        arr.forEach(function (item, i) {
            _this.recycleCell(item, i + shift);
        });
        // if (debug) {
        //   verifyRow(row, -1, this.context.columns);
        // }
    };
    ACellAdapter.prototype.selectProxyCell = function (row, column, columns) {
        var pool = this.cellPool[column];
        var columnObj = columns[column];
        var item;
        var ready;
        var pooled = pool.pop();
        var r = pooled
            ? this.updateCell(pooled, row, columnObj) || pooled
            : this.createCell(this.header.ownerDocument, row, columnObj);
        if (isAsyncUpdate(r)) {
            item = r.item;
            ready = r.ready;
        }
        else {
            item = r;
        }
        if (item !== pooled) {
            item.dataset.id = columnObj.id;
            item.classList.add(CSS_CLASS_TD, this.style.cssClasses.td, cssClass("td-".concat(this.tableId)));
        }
        this.updateShiftedState(item, columnObj);
        return { item: item, ready: ready };
    };
    ACellAdapter.prototype.handleCellReady = function (item, ready, column) {
        var _this = this;
        if (column === void 0) { column = -1; }
        item.classList.add(CSS_CLASS_LOADING);
        var abort = ready;
        // lazy loading
        this.loading.set(item, abort);
        abort.then(function (result) {
            _this.loading.delete(item);
            item.classList.remove(CSS_CLASS_LOADING);
            if (result === ABORTED && column >= 0) {
                // aborted can recycle the real one
                _this.cellPool[column].push(item);
            }
        });
        return item;
    };
    ACellAdapter.prototype.selectCell = function (row, column, columns) {
        var _a = this.selectProxyCell(row, column, columns), item = _a.item, ready = _a.ready;
        if (!isAbortAble(ready)) {
            return item;
        }
        return this.handleCellReady(item, ready, column);
    };
    ACellAdapter.prototype.updateShiftedState = function (node, col) {
        node.classList.toggle(CSS_CLASS_SHIFTED, col.frozen && this.horizontallyShifted);
    };
    ACellAdapter.prototype.recycleCell = function (item, column) {
        if (column === void 0) { column = -1; }
        // check if the dom element is still being manipulated
        var abort = this.loading.get(item);
        if (abort != null) {
            abort.abort();
        }
        else if (!isLoadingCell(item) && column >= 0) {
            this.cellPool[column].push(item);
        }
    };
    ACellAdapter.prototype.addColumnAtStart = function (from, to, frozenShift) {
        var _this = this;
        if (frozenShift === void 0) { frozenShift = this.visibleColumns.frozen.length; }
        var columns = this.context.columns;
        this.forEachRow(function (row, rowIndex) {
            _this.addCellAtStart(row, rowIndex, from, to, frozenShift, columns);
        });
        // if (debug) {
        //   this.verifyRows();
        // }
    };
    ACellAdapter.prototype.addCellAtStart = function (row, rowIndex, from, to, frozenShift, columns) {
        // if (debug) {
        //   verifyRow(row, rowIndex, this.context.columns);
        // }
        for (var i = to; i >= from; i -= 1) {
            var cell = this.selectCell(rowIndex, i, columns);
            row.insertBefore(cell, frozenShift > 0 ? row.children[frozenShift] : row.firstChild);
        }
        // if (debug) {
        //   verifyRow(row, rowIndex, this.context.columns);
        // }
    };
    ACellAdapter.prototype.insertFrozenCells = function (row, rowIndex, columnIndices, shift, columns) {
        var before = row.children[shift];
        for (var _i = 0, columnIndices_2 = columnIndices; _i < columnIndices_2.length; _i++) {
            var i = columnIndices_2[_i];
            var cell = this.selectCell(rowIndex, i, columns);
            if (before) {
                row.insertBefore(cell, before);
            }
            else {
                row.appendChild(cell);
            }
        }
    };
    ACellAdapter.prototype.insertFrozenColumns = function (columnIndices, shift) {
        var _this = this;
        var columns = this.context.columns;
        this.forEachRow(function (row, rowIndex) {
            _this.insertFrozenCells(row, rowIndex, columnIndices, shift, columns);
        });
    };
    ACellAdapter.prototype.addColumnAtEnd = function (from, to) {
        var _this = this;
        var columns = this.context.columns;
        this.forEachRow(function (row, rowIndex) {
            _this.addCellAtEnd(row, rowIndex, from, to, columns);
        });
        // if (debug) {
        //   this.verifyRows();
        // }
    };
    // private verifyRows() {
    //   const { columns } = this.context;
    //   this.forEachRow((row, rowIndex) => verifyRow(row, rowIndex, columns));
    // }
    ACellAdapter.prototype.addCellAtEnd = function (row, rowIndex, from, to, columns) {
        for (var i = from; i <= to; i += 1) {
            var cell = this.selectCell(rowIndex, i, columns);
            row.appendChild(cell);
        }
        // if (debug) {
        //   verifyRow(row, rowIndex, this.context.columns);
        // }
    };
    ACellAdapter.prototype.updateHeaders = function () {
        var _this = this;
        var columns = this.context.columns;
        Array.from(this.header.children).forEach(function (node, i) {
            var base = node;
            var col = columns[i];
            var r = _this.updateHeader(base, col);
            var n;
            if (isAsyncUpdate(r)) {
                n = _this.handleCellReady(r.item, r.ready, -1);
            }
            else {
                n = r || base;
            }
            if (n === base) {
                return;
            }
            n.dataset.id = col.id;
            n.classList.add(CSS_CLASS_TH, _this.style.cssClasses.th, cssClass("th-".concat(_this.tableId)));
            _this.header.replaceChild(base, n);
        });
    };
    ACellAdapter.prototype.recreate = function (left, width) {
        var _this = this;
        var _a;
        var context = this.context;
        this.style.update(context.defaultRowHeight - context.padding(-1), context.columns, context.column.padding, 0, this.tableId);
        this.clearPool();
        // init pool
        for (var i = this.cellPool.length; i < context.columns.length; i += 1) {
            this.cellPool.push([]);
        }
        // create all header columns
        {
            var fragment_1 = this.columnFragment;
            var document_1 = fragment_1.ownerDocument;
            // create lookup cache to reuse headers
            var ids_1 = new Map();
            while (this.header.lastChild) {
                var c = this.header.lastChild;
                this.header.removeChild(c);
                ids_1.set((_a = c.dataset.id) !== null && _a !== void 0 ? _a : '', c);
            }
            context.columns.forEach(function (col) {
                var existing = ids_1.get(col.id);
                var r = existing ? _this.updateHeader(existing, col) || existing : _this.createHeader(document_1, col);
                var n;
                if (isAsyncUpdate(r)) {
                    n = _this.handleCellReady(r.item, r.ready, -1);
                }
                else {
                    n = r;
                }
                if (n !== existing) {
                    n.dataset.id = col.id;
                    n.classList.add(CSS_CLASS_TH, _this.style.cssClasses.th, cssClass("th-".concat(_this.tableId)));
                }
                fragment_1.appendChild(n);
            });
            this.header.appendChild(fragment_1);
        }
        var _b = range(left, width, context.column.defaultRowHeight, context.column.exceptions, context.column.numberOfRows), first = _b.first, last = _b.last, firstRowPos = _b.firstRowPos;
        this.visibleColumns.first = first;
        this.visibleColumns.forcedFirst = first;
        this.visibleColumns.last = last;
        this.visibleColumns.forcedLast = last;
        if (context.columns.some(function (c) { return c.frozen; })) {
            var target = updateFrozen([], context.columns, first).target;
            this.visibleColumns.frozen = target;
        }
        else {
            this.visibleColumns.frozen = [];
        }
        this.updateColumnOffset(firstRowPos);
    };
    ACellAdapter.prototype.clearPool = function () {
        this.cellPool.forEach(function (p) { return p.splice(0, p.length); });
    };
    ACellAdapter.prototype.updateColumnOffset = function (firstColumnPos) {
        var changed = firstColumnPos !== this.visibleFirstColumnPos;
        this.visibleFirstColumnPos = firstColumnPos;
        if (changed) {
            var context = this.context;
            this.style.update(context.defaultRowHeight - context.padding(-1), context.columns, context.column.padding, 0, this.tableId);
        }
    };
    ACellAdapter.prototype.createRow = function (node, rowIndex) {
        var columns = this.context.columns;
        var visible = this.visibleColumns;
        if (visible.frozen.length > 0) {
            for (var _i = 0, _a = visible.frozen; _i < _a.length; _i++) {
                var i = _a[_i];
                var cell = this.selectCell(rowIndex, i, columns);
                node.appendChild(cell);
            }
        }
        for (var i = visible.first; i <= visible.last; i += 1) {
            var cell = this.selectCell(rowIndex, i, columns);
            node.appendChild(cell);
        }
    };
    ACellAdapter.prototype.updateRow = function (node, rowIndex) {
        var _a;
        var columns = this.context.columns;
        var visible = this.visibleColumns;
        // columns may not match anymore if it is a pooled item a long time ago
        switch (node.childElementCount) {
            case 0:
                if (visible.frozen.length > 0) {
                    this.insertFrozenCells(node, rowIndex, visible.frozen, 0, columns);
                }
                this.addCellAtEnd(node, rowIndex, visible.first, visible.last, columns);
                break;
            case 1: {
                var old = node.firstElementChild;
                var id_1 = (_a = old.dataset.id) !== null && _a !== void 0 ? _a : '';
                var columnIndex = columns.findIndex(function (c) { return c.id === id_1; });
                node.removeChild(old);
                if (columnIndex >= 0) {
                    this.recycleCell(old, columnIndex);
                }
                if (visible.frozen.length > 0) {
                    this.insertFrozenCells(node, rowIndex, visible.frozen, 0, columns);
                }
                this.addCellAtEnd(node, rowIndex, visible.first, visible.last, columns);
                break;
            }
            default:
                this.mergeColumns(node, rowIndex);
                break;
        }
    };
    ACellAdapter.prototype.mergeColumns = function (node, rowIndex) {
        var _this = this;
        var columns = this.context.columns;
        var visible = this.visibleColumns;
        var ids = new Map();
        while (node.lastChild) {
            var c = node.lastChild;
            node.removeChild(c);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ids.set(c.dataset.id, c);
        }
        var updateImpl = function (i) {
            var col = columns[i];
            var existing = ids.get(col.id);
            if (!existing) {
                var cell_1 = _this.selectCell(rowIndex, i, columns);
                node.appendChild(cell_1);
                return;
            }
            ids.delete(col.id);
            var r = _this.updateCell(existing, rowIndex, col) || existing;
            var cell;
            if (isAsyncUpdate(r)) {
                cell = _this.handleCellReady(r.item, r.ready, i);
            }
            else {
                cell = r;
            }
            if (cell && cell !== existing) {
                cell.dataset.id = col.id;
                cell.classList.add(CSS_CLASS_TD, _this.style.cssClasses.td, cssClass("td-".concat(_this.tableId)));
            }
            _this.updateShiftedState(cell, col);
            node.appendChild(cell);
        };
        for (var _i = 0, _a = visible.frozen; _i < _a.length; _i++) {
            var frozen = _a[_i];
            updateImpl(frozen);
        }
        for (var i = visible.first; i <= visible.last; i += 1) {
            updateImpl(i);
        }
        if (ids.size === 0) {
            return;
        }
        // recycle
        var byId = new Map(columns.map(function (d, i) { return [d.id, i]; }));
        ids.forEach(function (idNode, key) {
            var index = byId.get(key);
            if (index != null && index >= 0) {
                _this.recycleCell(idNode, index);
            }
        });
    };
    ACellAdapter.prototype.updateShiftedStates = function () {
        if (!this.context.columns.some(function (d) { return d.frozen; })) {
            return;
        }
        var shifted = this.horizontallyShifted;
        var clazz = CSS_CLASS_SHIFTED;
        if (shifted) {
            var headers = Array.from(this.header.querySelectorAll(".".concat(CSS_CLASS_FROZEN, ":not(.").concat(clazz, ")")));
            var bodies = Array.from(this.body.querySelectorAll(".".concat(CSS_CLASS_FROZEN, ":not(.").concat(clazz, ")")));
            for (var _i = 0, headers_1 = headers; _i < headers_1.length; _i++) {
                var item = headers_1[_i];
                item.classList.add(clazz);
            }
            for (var _a = 0, bodies_1 = bodies; _a < bodies_1.length; _a++) {
                var item = bodies_1[_a];
                item.classList.add(clazz);
            }
        }
        else {
            var headers = Array.from(this.header.querySelectorAll(".".concat(CSS_CLASS_FROZEN, ".").concat(clazz)));
            var bodies = Array.from(this.body.querySelectorAll(".".concat(CSS_CLASS_FROZEN, ".").concat(clazz)));
            for (var _b = 0, headers_2 = headers; _b < headers_2.length; _b++) {
                var item = headers_2[_b];
                item.classList.remove(clazz);
            }
            for (var _c = 0, bodies_2 = bodies; _c < bodies_2.length; _c++) {
                var item = bodies_2[_c];
                item.classList.remove(clazz);
            }
        }
    };
    ACellAdapter.prototype.syncFrozen = function (first) {
        var columns = this.context.columns;
        var visible = this.visibleColumns;
        if (!columns.some(function (d) { return d.frozen; })) {
            return 0;
        }
        if (first === 0) {
            if (visible.frozen.length > 0) {
                this.removeFrozenColumns(visible.frozen, 0);
                visible.frozen = [];
            }
            return 0;
        }
        var old = visible.frozen.length;
        var _a = updateFrozen(visible.frozen, columns, first), target = _a.target, added = _a.added, removed = _a.removed;
        if (removed.length > 0) {
            this.removeFrozenColumns(removed, old - removed.length);
        }
        if (added.length > 0) {
            this.insertFrozenColumns(added, old - removed.length);
        }
        visible.frozen = target;
        return target.length;
    };
    ACellAdapter.prototype.onScrolledHorizontallyImpl = function (scrollLeft, clientWidth) {
        var shiftingChanged = this.horizontallyShifted !== scrollLeft > 0;
        this.horizontallyShifted = scrollLeft > 0;
        var column = this.context.column;
        var _a = range(scrollLeft, clientWidth, column.defaultRowHeight, column.exceptions, column.numberOfRows), first = _a.first, last = _a.last, firstRowPos = _a.firstRowPos;
        var visible = this.visibleColumns;
        visible.forcedFirst = first;
        visible.forcedLast = last;
        if (first - visible.first >= 0 && last - visible.last <= 0) {
            // nothing to do
            if (shiftingChanged) {
                this.updateShiftedStates();
            }
            return EScrollResult.NONE;
        }
        var r = EScrollResult.SOME;
        var frozenShift = this.syncFrozen(first);
        if (first > visible.last || last < visible.first) {
            // no overlap, clean and draw everything
            // console.log(
            //   `ff added: ${last - first + 1} removed: ${visible.last - visible.first + 1} ${first}:${last} ${frozenShift}`
            // );
            // removeRows(visibleFirst, visibleLast);
            this.removeAllColumns(false);
            // this.updateShiftedStates();
            this.addColumnAtEnd(first, last);
            r = EScrollResult.ALL;
        }
        else if (first < visible.first) {
            // some first rows missing and some last rows to much
            // console.log(
            //   `up added: ${visible.first - first + 1} removed: ${visible.last - last + 1} ${first}:${last} ${frozenShift}`
            // );
            this.removeColumnFromEnd(last + 1, visible.last);
            this.updateShiftedStates();
            this.addColumnAtStart(first, visible.first - 1, frozenShift);
            r = EScrollResult.SOME_TOP;
        }
        else {
            // console.log(
            //   `do added: ${last - visible.last + 1} removed: ${first - visible.first + 1} ${first}:${last} ${frozenShift}`
            // );
            // some last rows missing and some first rows to much
            this.removeColumnFromStart(visible.first, first - 1, frozenShift);
            this.updateShiftedStates();
            this.addColumnAtEnd(visible.last + 1, last);
            r = EScrollResult.SOME_BOTTOM;
        }
        visible.first = first;
        visible.last = last;
        this.updateColumnOffset(firstRowPos);
        return r;
    };
    return ACellAdapter;
}());
export { ACellAdapter };
/**
 * @internal
 */
export default ACellAdapter;
// function verifyRow(row: HTMLElement, index: number, columns: IColumn[]) {
//   const cols = Array.from(row.children) as HTMLElement[];
//   // sort incrementally
//   if (cols.length <= 1) {
//     return;
//   }
//   const colObjs = cols.map((c) => columns.find((d) => d.id === c.dataset.id));
//   console.assert(
//     colObjs.every((d) => Boolean(d)),
//     'all columns must exist',
//     index
//   );
//   console.assert(
//     colObjs.every((d, i) => i === 0 || d.index >= colObjs[i - 1]!.index),
//     'all columns in ascending order',
//     index
//   );
//   console.assert(new Set(colObjs).size === colObjs.length, 'unique columns', colObjs);
// }
//# sourceMappingURL=ACellAdapter.js.map