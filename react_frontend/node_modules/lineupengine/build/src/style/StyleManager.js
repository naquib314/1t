// import manually import './style.scss';
function assignStyles(target, source) {
    var targetObj = target;
    for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
        var key = _a[_i];
        var v = source[key];
        if (!v.endsWith(' !important')) {
            if (targetObj[key] !== v) {
                // eslint-disable-next-line no-param-reassign
                targetObj[key] = v;
            }
            continue;
        }
        // handle special important case
        var plain = v.slice(0, -' !important'.length);
        if (targetObj[key] === plain) {
            continue;
        }
        // eslint-disable-next-line no-param-reassign
        targetObj[key] = plain;
        // see https://gist.github.com/youssman/745578062609e8acac9f
        var hyphen = key.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
        target.setProperty(hyphen, plain, 'important');
    }
}
var StyleManager = /** @class */ (function () {
    /**
     * the parent element to append this managed style
     * @param {HTMLElement} root
     */
    function StyleManager(root) {
        this.rules = [];
        this.testVerifyTimeout = -1;
        this.node = root.ownerDocument.createElement('style');
        this.node.appendChild(root.ownerDocument.createTextNode('')); // for webkit?
        root.appendChild(this.node);
    }
    StyleManager.prototype.destroy = function () {
        this.node.remove();
    };
    StyleManager.prototype.verifySheet = function () {
        var _this = this;
        var sheet = this.sheet;
        if (!sheet) {
            if (this.testVerifyTimeout >= 0) {
                return;
            }
            // test till attached
            // eslint-disable-next-line no-restricted-globals
            this.testVerifyTimeout = self.setTimeout(function () {
                _this.testVerifyTimeout = -1;
                _this.verifySheet();
            }, 20);
            return;
        }
        var rules = sheet.cssRules;
        if (rules.length === this.rules.length &&
            this.rules.every(function (d, i) { return rules[i].selectorText === d.selector; })) {
            // same
            return;
        }
        // console.warn('invalid sheet rules detected');
        var l = rules.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            sheet.deleteRule(i);
        }
        // create all
        for (var _i = 0, _a = this.rules; _i < _a.length; _i++) {
            var rule = _a[_i];
            var index = sheet.insertRule("".concat(rule.selector, " {}"), sheet.cssRules.length);
            var cssRule = sheet.cssRules[index];
            rule.selector = cssRule.selectorText;
            assignStyles(cssRule.style, rule.style);
        }
    };
    Object.defineProperty(StyleManager.prototype, "sheet", {
        get: function () {
            return this.node.sheet;
        },
        enumerable: false,
        configurable: true
    });
    StyleManager.prototype.getSheetRule = function (index) {
        var sheet = this.sheet;
        return sheet ? sheet.cssRules[index] : null;
    };
    /**
     * add a custom css rule
     * @param {string} id unique id of the rule for later identification
     * @param {string} selector the css selector
     * @param {Partial<CSSStyleDeclaration>} style the style attributes
     * @returns {string} the id again
     */
    StyleManager.prototype.addRule = function (id, selector, style) {
        this.verifySheet();
        var sheet = this.sheet;
        if (!sheet) {
            // upon next update
            this.rules.push({ id: id, selector: selector, style: style });
            return null;
        }
        var index = sheet.insertRule("".concat(selector, " {}"), sheet.cssRules.length);
        var rule = sheet.cssRules[index];
        this.rules.push({ id: id, selector: rule.selectorText, style: style });
        assignStyles(rule.style, style);
        return id;
    };
    /**
     * updates or add a rule, see @addRule
     * @param {string} id unique id of the rule for later identification
     * @param {string} selector the css selector
     * @param {Partial<CSSStyleDeclaration>} style the style attributes
     * @returns {string} the id again
     */
    StyleManager.prototype.updateRule = function (id, selector, style) {
        this.verifySheet();
        var index = this.rules.findIndex(function (d) { return d.id === id; });
        if (index < 0) {
            return this.addRule(id, selector, style);
        }
        var stored = this.rules[index];
        stored.selector = selector;
        stored.style = style;
        var rule = this.getSheetRule(index);
        if (rule) {
            if (rule.selectorText.replace(/\s/gm, '') !== selector.replace(/\s/gm, '')) {
                // ignoring white space
                rule.selectorText = selector;
                stored.selector = rule.selectorText;
            }
            assignStyles(rule.style, style);
        }
        return id;
    };
    /**
     * deletes the given rule by id
     * @param {string} id the rule to delete
     */
    StyleManager.prototype.deleteRule = function (id) {
        this.verifySheet();
        var index = this.rules.findIndex(function (d) { return d.id === id; });
        if (index < 0) {
            return;
        }
        this.rules.splice(index, 1);
        var sheet = this.sheet;
        if (sheet) {
            sheet.deleteRule(index);
        }
    };
    Object.defineProperty(StyleManager.prototype, "ruleNames", {
        /**
         * get a list of all registered rule ids
         */
        get: function () {
            return this.rules.map(function (d) { return d.id; });
        },
        enumerable: false,
        configurable: true
    });
    return StyleManager;
}());
export default StyleManager;
//# sourceMappingURL=StyleManager.js.map