import { IDelayedMode } from '../internal';
import { GridStyleManager } from '../style';
/**
 * basic interface of a table section
 */
export interface ITableSection {
    readonly id: string;
    readonly width: number;
    readonly height: number;
    readonly header: HTMLElement;
    readonly body: HTMLElement;
    init(): void;
    /**
     * show the section
     * @param {number} left visible left margin
     * @param {number} width visible width
     * @param {boolean} isGoingRight whether it was a shift to the right
     */
    show(left: number, width: number, isGoingRight: boolean): void;
    hide(): void;
    destroy(): void;
}
export interface ITableFactory<T extends ITableSection> {
    (header: HTMLElement, body: HTMLElement, tableId: string, style: GridStyleManager, ...extras: unknown[]): T;
}
export interface ISeparatorFactory<T extends ITableSection> {
    (header: HTMLElement, body: HTMLElement, style: GridStyleManager, ...extras: unknown[]): T;
}
export interface IMultiTableRowRendererOptions {
    /**
     * column padding to use between columns
     * @default 0
     */
    columnPadding: number;
    /**
     * async update on scrolling
     * animation -> use requestAnimationFrame
     * sync -> execute within scroll listener
     * {number} -> execute within this delay using setTimeout
     * @default is chrome ? animation else 0
     */
    async: IDelayedMode;
    /**
     * minimal number of pixel the scrollbars has to move
     * @default 30
     */
    minScrollDelta: number;
}
/**
 * manager of multiple columns separated by separators each an own row renderer
 */
export default class MultiTableRowRenderer {
    readonly node: HTMLElement;
    readonly style: GridStyleManager;
    private tableId;
    private readonly sections;
    private readonly options;
    constructor(node: HTMLElement, htmlId: string, options?: Partial<IMultiTableRowRendererOptions>);
    private update;
    private onScrolledHorizontally;
    private updateOffset;
    destroy(): void;
    private get doc();
    private get header();
    private get main();
    /**
     * push another table to this instance
     * @param {ITableFactory<T extends ITableSection>} factory factory for the table
     * @param extras additional arguments to provide for the factory
     * @returns {T} the table instance
     */
    pushTable<T extends ITableSection>(factory: ITableFactory<T>, ...extras: unknown[]): T;
    /**
     * push another separator to the manager
     * @param {ISeparatorFactory<T extends ITableSection>} factory the factory to create the separator
     * @param extras optional additional arguments
     * @returns {T} the new created separator
     */
    pushSeparator<T extends ITableSection>(factory: ISeparatorFactory<T>, ...extras: unknown[]): T;
    /**
     * removes a given table section
     * @param {ITableSection} section section to remove
     * @returns {boolean} successful flag
     */
    remove(section: ITableSection): boolean;
    clear(): void;
    /**
     * triggers and update because of a change in width of one or more table sections
     */
    widthChanged(): void;
}
//# sourceMappingURL=MultiTableRowRenderer.d.ts.map