var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { ABORTED, isAbortAble } from './abortAble';
import { defaultPhases, EAnimationMode, noAnimationChange, } from './animation';
import KeyFinder from './animation/KeyFinder';
import { addScroll, clear, defaultMode, removeScroll } from './internal';
import { isScrollEventWaiting } from './internal/scroll';
import { range } from './logic';
import { EScrollResult } from './mixin';
import { cssClass, CSS_CLASS_EVEN, CSS_CLASS_FOOTER, CSS_CLASS_LOADING, CSS_CLASS_ROW_ANIMATION, CSS_CLASS_SCROLLING, CSS_CLASS_TR, } from './styles';
export function isLoadingCell(node) {
    return node.classList.contains(CSS_CLASS_LOADING);
}
/**
 * base class for creating a scalable table renderer based on rows
 */
var ARowRenderer = /** @class */ (function () {
    function ARowRenderer(body, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.body = body;
        this.pool = [];
        this.loadingPool = [];
        this.loading = new WeakMap();
        /**
         * currently visible slice
         */
        this.visible = {
            first: 0,
            forcedFirst: 0,
            last: -1,
            forcedLast: -1,
        };
        /**
         * position of the first visible row in pixel
         * @type {number}
         */
        this.visibleFirstRowPos = 0;
        this.scrollListener = null;
        this.lastScrollInfo = null;
        this.abortAnimation = function () { return undefined; };
        this.options = {
            async: defaultMode,
            minScrollDelta: 10,
            mixins: [],
            scrollingHint: false,
            batchSize: 10,
            striped: false,
            viewportOversize: 200,
        };
        this.adapter = this.createAdapter();
        Object.assign(this.options, options);
        this.mixins = this.options.mixins.map(function (MixinClass) { return new MixinClass(_this.adapter); });
        this.fragment = body.ownerDocument.createDocumentFragment();
    }
    /**
     * register another mixin to this renderer
     * @param {IMixinClass} MixinClass the mixin class to instantiate
     * @param options optional constructor options
     */
    ARowRenderer.prototype.addMixin = function (MixinClass, options) {
        this.mixins.push(new MixinClass(this.adapter, options));
    };
    ARowRenderer.prototype.createAdapter = function () {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var that = this;
        return {
            visible: this.visible,
            addAtBeginning: function (from, to) { return _this.addAtBeginning(from, to); },
            addAtBottom: this.addAtBottom.bind(this),
            removeFromBeginning: function (from, to) { return _this.removeFromBeginning(from, to); },
            removeFromBottom: this.removeFromBottom.bind(this),
            updateOffset: this.updateOffset.bind(this),
            isScrollEventWaiting: function () { return isScrollEventWaiting(_this.bodyScroller, _this.options.async); },
            get visibleFirstRowPos() {
                return that.visibleFirstRowPos;
            },
            get context() {
                return that.context;
            },
            get scrollOffset() {
                return that.lastScrollInfo ? that.lastScrollInfo.top : 0;
            },
            get scrollTotal() {
                return that.lastScrollInfo ? that.lastScrollInfo.height : that.bodyScroller.clientHeight;
            },
        };
    };
    Object.defineProperty(ARowRenderer.prototype, "bodyScroller", {
        /**
         * get the scrolling container i.e. parent of the body element
         * @returns {HTMLElement}
         */
        get: function () {
            return this.body.parentElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ARowRenderer.prototype, "bodySizer", {
        get: function () {
            var parent = this.bodyScroller;
            var sizer = Array.from(parent.children).find(function (d) { return d.tagName.toLowerCase() === 'footer'; });
            if (sizer) {
                return sizer;
            }
            var s = parent.ownerDocument.createElement('footer');
            s.classList.add(CSS_CLASS_FOOTER, cssClass("footer-".concat(this.idPrefix)));
            parent.insertBefore(s, parent.firstChild);
            return s;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * initializes the table and register the onscroll listener
     * @returns {void} nothing
     */
    ARowRenderer.prototype.init = function () {
        var _this = this;
        var scroller = this.bodyScroller;
        var old = addScroll(scroller, this.options.async, (this.scrollListener = function (act) {
            _this.lastScrollInfo = act;
            if (Math.abs(old.top - act.top) < _this.options.minScrollDelta &&
                Math.abs(old.height - act.height) < _this.options.minScrollDelta) {
                return;
            }
            var isGoingDown = act.top > old.top;
            old = act;
            _this.onScrolledVertically(act.top, act.height, isGoingDown);
            if (_this.options.scrollingHint) {
                _this.body.classList.remove(CSS_CLASS_SCROLLING);
            }
        }));
        if (this.options.scrollingHint) {
            addScroll(scroller, 'animation', function () { return _this.body.classList.add(CSS_CLASS_SCROLLING); });
        }
        this.recreate();
    };
    /**
     * destroys this renderer and unregisters all event listeners
     */
    ARowRenderer.prototype.destroy = function () {
        if (this.scrollListener) {
            removeScroll(this.bodyScroller, this.scrollListener);
        }
        this.body.remove();
    };
    ARowRenderer.cleanUp = function (item) {
        // eslint-disable-next-line no-param-reassign
        item.style.height = '';
    };
    ARowRenderer.prototype.select = function (index) {
        var item = this.pool.pop();
        var result;
        if (item != null) {
            result = this.updateRow(item, index);
        }
        else {
            item = this.loadingPool.pop();
            if (item != null) {
                item.classList.remove(CSS_CLASS_LOADING);
                result = this.createRow(item, index);
            }
            else {
                item = this.body.ownerDocument.createElement('div');
                item.classList.add(CSS_CLASS_TR, cssClass("tr-".concat(this.idPrefix)));
                result = this.createRow(item, index);
            }
        }
        item.dataset.index = String(index);
        if (this.options.striped) {
            item.classList.toggle(CSS_CLASS_EVEN, index % 2 === 0);
        }
        return { item: item, result: result };
    };
    ARowRenderer.prototype.selectProxy = function () {
        var proxy = this.loadingPool.pop();
        if (proxy == null) {
            proxy = this.body.ownerDocument.createElement('div');
            proxy.classList.add(CSS_CLASS_LOADING, CSS_CLASS_TR, cssClass("tr-".concat(this.idPrefix)));
        }
        return proxy;
    };
    ARowRenderer.prototype.recycle = function (item) {
        ARowRenderer.cleanUp(item);
        // check if the original dom element is still being manipulated
        var abort = this.loading.get(item);
        if (abort != null) {
            abort.abort();
        }
        else {
            this.pool.push(item);
        }
    };
    ARowRenderer.prototype.proxy = function (item, result) {
        var _this = this;
        if (!isAbortAble(result)) {
            return item;
        }
        var abort = result;
        // lazy loading
        var real = item;
        var proxy = this.selectProxy();
        // copy attributes
        proxy.dataset.index = real.dataset.index;
        proxy.style.height = real.style.height;
        this.loading.set(proxy, abort);
        abort.then(function (abortResult) {
            if (abortResult === ABORTED) {
                // aborted can recycle the real one
                ARowRenderer.cleanUp(real);
                _this.pool.push(real);
            }
            else {
                // fully loaded
                _this.body.replaceChild(real, proxy);
            }
            _this.loading.delete(proxy);
            ARowRenderer.cleanUp(proxy);
            _this.loadingPool.push(proxy);
        }, function () {
            // handle as aborted
            // aborted can recycle the real one
            ARowRenderer.cleanUp(real);
            _this.pool.push(real);
            _this.loading.delete(proxy);
            ARowRenderer.cleanUp(proxy);
            _this.loadingPool.push(proxy);
        });
        return proxy;
    };
    ARowRenderer.prototype.create = function (index) {
        var _a = this.select(index), item = _a.item, result = _a.result;
        var _b = this.context, ex = _b.exceptionsLookup, padding = _b.padding;
        var exceptionHeight = ex.get(index);
        if (exceptionHeight != null) {
            item.style.height = "".concat(exceptionHeight - padding(index), "px");
        }
        return this.proxy(item, result);
    };
    ARowRenderer.prototype.removeAll = function (perform) {
        if (perform === void 0) { perform = true; }
        var b = this.body;
        if (!perform) {
            return Array.from(b.children);
        }
        var toRecycle = [];
        while (b.lastElementChild) {
            var i = b.lastElementChild;
            b.removeChild(i);
            this.recycle(i);
            toRecycle.push(i);
        }
        return toRecycle;
    };
    /**
     * triggers and visual update of all visible rows
     */
    ARowRenderer.prototype.update = function () {
        var _this = this;
        var first = this.visible.first;
        var fragment = this.fragment;
        var items = Array.from(this.body.children);
        clear(this.body);
        items.forEach(function (item, i) {
            if (_this.loading.has(item)) {
                // still loading
                fragment.appendChild(item);
                return;
            }
            var abort = _this.updateRow(item, i + first);
            fragment.appendChild(_this.proxy(item, abort));
        });
        this.body.appendChild(fragment);
    };
    /**
     * utility to execute a function for each visible row
     * @param {(row: HTMLElement, rowIndex: number) => void} callback callback to execute
     * @param {boolean} inPlace whether the DOM changes should be performed in place instead of in a fragment
     */
    ARowRenderer.prototype.forEachRow = function (callback, inPlace) {
        var _this = this;
        if (inPlace === void 0) { inPlace = false; }
        var rows = Array.from(this.body.children);
        var fragment = this.fragment;
        if (!inPlace) {
            clear(this.body);
        }
        rows.forEach(function (row, index) {
            if (!isLoadingCell(row) && row.dataset.animation !== 'update_remove' && row.dataset.animation !== 'hide') {
                // skip loading ones and temporary ones
                callback(row, index + _this.visible.first);
            }
            if (!inPlace) {
                fragment.appendChild(row);
            }
        });
        if (!inPlace) {
            this.body.appendChild(fragment);
        }
    };
    ARowRenderer.prototype.removeFromBeginning = function (from, to, perform) {
        if (perform === void 0) { perform = true; }
        return this.remove(from, to, true, perform);
    };
    ARowRenderer.prototype.removeFromBottom = function (from, to, perform) {
        if (perform === void 0) { perform = true; }
        return this.remove(from, to, false, perform);
    };
    ARowRenderer.prototype.remove = function (from, to, fromBeginning, perform) {
        if (perform === void 0) { perform = true; }
        if (to < from) {
            return [];
        }
        var b = this.body;
        var toRecycle = [];
        // console.log('remove', fromBeginning, (to - from) + 1, this.body.childElementCount - ((to - from) + 1));
        var act = (fromBeginning ? b.firstChild : b.lastChild);
        for (var i = from; i <= to; i += 1) {
            var item = act;
            act = (fromBeginning ? act.nextSibling : act.previousSibling);
            if (perform) {
                b.removeChild(item);
                this.recycle(item);
            }
            toRecycle.push(item);
        }
        return toRecycle;
    };
    ARowRenderer.prototype.addAtBeginning = function (from, to, perform) {
        if (perform === void 0) { perform = true; }
        if (to < from) {
            return null;
        }
        // console.log('add', (to - from) + 1, this.body.childElementCount + ((to - from) + 1));
        var fragment = this.fragment;
        if (from === to && perform) {
            this.body.insertBefore(this.create(from), this.body.firstChild);
            return null;
        }
        for (var i = from; i <= to; i += 1) {
            fragment.appendChild(this.create(i));
        }
        if (perform) {
            this.body.insertBefore(fragment, this.body.firstChild);
        }
        return fragment;
    };
    ARowRenderer.prototype.addAtBottom = function (from, to, perform) {
        if (perform === void 0) { perform = true; }
        if (to < from) {
            return null;
        }
        // console.log('add_b', (to - from) + 1, this.body.childElementCount + ((to - from) + 1));
        if (from === to && perform) {
            this.body.appendChild(this.create(from));
            return null;
        }
        var fragment = this.fragment;
        for (var i = from; i <= to; i += 1) {
            fragment.appendChild(this.create(i));
        }
        if (perform) {
            this.body.appendChild(fragment);
        }
        return fragment;
    };
    ARowRenderer.prototype.updateOffset = function (firstRowPos) {
        this.visibleFirstRowPos = firstRowPos;
        this.updateSizer(firstRowPos);
    };
    ARowRenderer.prototype.updateSizer = function (firstRowPos) {
        var totalHeight = this.context.totalHeight;
        setTransform(this.body, 0, firstRowPos.toFixed(0));
        setTransform(this.bodySizer, 0, Math.max(0, totalHeight - 1).toFixed(0));
    };
    /**
     * removes all rows and recreates the table
     * @param {IAnimationContext} ctx optional animation context to create a transition between the previous and the current tables
     * @returns {void} nothing
     */
    ARowRenderer.prototype.recreate = function (ctx) {
        this.abortAnimation();
        if (ctx) {
            return this.recreateAnimated(ctx);
        }
        return this.recreatePure();
    };
    ARowRenderer.prototype.recreatePure = function () {
        var context = this.context;
        var scroller = this.bodyScroller;
        // update first to avoid resetting scrollTop
        this.updateOffset(0);
        this.removeAll();
        this.clearPool();
        var _a = range(scroller.scrollTop, scroller.clientHeight, context.defaultRowHeight, context.exceptions, context.numberOfRows), first = _a.first, last = _a.last, firstRowPos = _a.firstRowPos;
        this.visible.first = first;
        this.visible.forcedFirst = first;
        this.visible.last = last;
        this.visible.forcedLast = last;
        if (first < 0) {
            // empty
            this.updateOffset(0);
            return;
        }
        this.addAtBottom(first, last);
        this.updateOffset(firstRowPos);
    };
    ARowRenderer.prototype.recreateAnimated = function (ctx) {
        var _this = this;
        var lookup = new Map();
        var prev = new KeyFinder(ctx.previous, ctx.previousKey);
        var cur = new KeyFinder(this.context, ctx.currentKey);
        var next = range(this.bodyScroller.scrollTop, this.bodyScroller.clientHeight, cur.context.defaultRowHeight, cur.context.exceptions, cur.context.numberOfRows);
        {
            var rows_1 = Array.from(this.body.children);
            var old = __assign({}, this.visible);
            // store the current rows in a lookup and clear
            clear(this.body);
            prev.positions(old.first, Math.min(old.last, old.first + rows_1.length), this.visibleFirstRowPos, function (i, key, pos) {
                var n = rows_1[i];
                if (n) {
                    // shouldn't happen that it is not there
                    lookup.set(key, { n: n, pos: pos, i: i });
                }
                // else {
                //  console.error(i, key, pos, rows);
                // }
            });
        }
        this.visible.first = next.first;
        this.visible.forcedFirst = next.first;
        this.visible.last = next.last;
        this.visible.forcedLast = next.last;
        var fragment = this.fragment;
        var animation = [];
        var nodeY = next.firstRowPos;
        cur.positions(next.first, next.last, next.firstRowPos, function (i, key, pos) {
            var node;
            var mode = EAnimationMode.UPDATE;
            var previous;
            var item = lookup.get(key);
            if (item != null) {
                // still visible
                lookup.delete(key);
                // update height
                item.n.dataset.index = String(i);
                node = _this.proxy(item.n, _this.updateRow(item.n, i));
                previous = {
                    index: item.i,
                    y: item.pos,
                    height: prev.exceptionHeightOf(item.i, true),
                };
            }
            else {
                // need a new row
                var old = prev.posByKey(key);
                // maybe not visible  before so keep in place
                node = _this.create(i);
                mode = old.index < 0 ? EAnimationMode.SHOW : EAnimationMode.UPDATE_CREATE;
                previous = {
                    index: old.index,
                    y: old.pos >= 0 ? old.pos : pos,
                    height: old.index < 0 ? cur.exceptionHeightOf(i, true) : prev.exceptionHeightOf(old.index, true),
                };
            }
            animation.push({
                node: node,
                key: key,
                mode: mode,
                previous: previous,
                nodeY: nodeY,
                nodeYCurrentHeight: pos,
                current: {
                    index: i,
                    y: pos,
                    height: cur.exceptionHeightOf(i),
                },
            });
            node.style.transform = "translate(0, ".concat(nodeY - pos, "px)");
            nodeY += previous.height + (previous.index < 0 ? cur.padding(i) : prev.padding(previous.index));
            fragment.appendChild(node);
        });
        var nodeYCurrentHeight = next.endPos;
        // items that are going to be removed
        lookup.forEach(function (item, key) {
            // calculate their next position
            var r = cur.posByKey(key);
            // maybe not visible anymore, keep in place
            var nextPos = r.pos >= 0 ? r.pos : item.pos;
            var node = item.n;
            // located at addedPos
            // should end up at nextPos
            // was previously at item.pos
            node.style.transform = "translate(0, ".concat(item.pos - nodeY, "px)");
            fragment.appendChild(node);
            var prevHeight = prev.exceptionHeightOf(item.i, true);
            animation.push({
                node: item.n,
                key: key,
                mode: r.index < 0 ? EAnimationMode.HIDE : EAnimationMode.UPDATE_REMOVE,
                previous: {
                    index: item.i,
                    y: item.pos,
                    height: prevHeight,
                },
                nodeY: nodeY,
                nodeYCurrentHeight: nodeYCurrentHeight,
                current: {
                    index: r.index,
                    y: nextPos,
                    height: r.index < 0 ? null : cur.exceptionHeightOf(r.index),
                },
            });
            nodeYCurrentHeight +=
                r.index < 0 ? cur.context.defaultRowHeight : cur.exceptionHeightOf(r.index, true) + cur.padding(r.index);
            nodeY += prevHeight + prev.padding(item.i);
        });
        this.updateOffset(next.firstRowPos);
        this.animate(animation, ctx.phases || defaultPhases, prev, cur, fragment);
    };
    ARowRenderer.prototype.animate = function (animation, phases, previousFinder, currentFinder, fragment) {
        var _this = this;
        var activeAnimation = animation;
        if (activeAnimation.length <= 0) {
            this.body.appendChild(fragment);
            return;
        }
        var currentTimer = -1;
        var actPhase = 0;
        var executePhase = function (phase, items) {
            if (items === void 0) { items = activeAnimation; }
            items.forEach(function (anim) { return phase.apply(anim, previousFinder, currentFinder); });
        };
        var run = function () {
            // dummy log for forcing dom update
            // eslint-disable-next-line no-console
            console.assert(activeAnimation[0].node.offsetTop >= 0, 'dummy log for forcing dom update');
            executePhase(phases[actPhase]);
            actPhase += 1;
            // shifted by one since already added through ++
            if (actPhase < phases.length) {
                // schedule the next one
                var next = phases[actPhase];
                // eslint-disable-next-line no-restricted-globals
                currentTimer = self.setTimeout(run, next.delay);
                return;
            }
            // last one
            var body = _this.body.classList;
            Array.from(body).forEach(function (v) {
                if (v.startsWith(cssClass()) && v.endsWith('-animation')) {
                    body.remove(v);
                }
            });
            // clean up
            activeAnimation.forEach(function (_a) {
                var node = _a.node, mode = _a.mode;
                if (mode !== EAnimationMode.UPDATE_REMOVE && mode !== EAnimationMode.HIDE) {
                    return;
                }
                node.remove();
                // eslint-disable-next-line no-param-reassign
                node.style.transform = '';
                _this.recycle(node);
            });
            _this.abortAnimation = function () { return undefined; };
            currentTimer = -1;
        };
        // execute all phases having a delay of zero
        while (phases[actPhase].delay === 0) {
            executePhase(phases[actPhase]);
            actPhase += 1;
        }
        // after the initial one
        var body = this.body;
        this.body.appendChild(fragment);
        var dummyAnimation = [];
        activeAnimation = activeAnimation.filter(function (d) {
            if (noAnimationChange(d, previousFinder.context.defaultRowHeight, currentFinder.context.defaultRowHeight)) {
                dummyAnimation.push(d);
                return false;
            }
            return true;
        });
        if (dummyAnimation.length > 0) {
            // execute all phases for them
            phases.slice(actPhase).forEach(function (phase) { return executePhase(phase, dummyAnimation); });
        }
        if (activeAnimation.length === 0) {
            return;
        }
        body.classList.add(CSS_CLASS_ROW_ANIMATION);
        new Set(activeAnimation.map(function (d) { return d.mode; })).forEach(function (mode) {
            // add class but map to UPDATE only
            body.classList.add(cssClass("".concat(EAnimationMode[mode].toLowerCase().split('_')[0], "-animation")));
        });
        this.abortAnimation = function () {
            if (currentTimer <= 0) {
                return;
            }
            // abort by removing
            clearTimeout(currentTimer);
            currentTimer = -1;
            // run the last phase
            actPhase = phases.length - 1;
            run();
        };
        // next tick such that DOM will be updated
        // eslint-disable-next-line no-restricted-globals
        currentTimer = self.setTimeout(run, phases[actPhase].delay);
    };
    /**
     * clears the row pool used for faster creation
     */
    ARowRenderer.prototype.clearPool = function () {
        // clear pool
        this.pool.splice(0, this.pool.length);
    };
    /**
     * triggers a revalidation of the current scrolling offset
     */
    ARowRenderer.prototype.revalidate = function () {
        var scroller = this.bodyScroller;
        this.onScrolledVertically(scroller.scrollTop, scroller.clientHeight, true);
        this.updateOffset(this.visibleFirstRowPos);
    };
    /**
     * scrolling vertically
     * @param {number} scrollTop top scrolling
     * @param {number} clientHeight visible height
     * @param {boolean} isGoingDown hint whether the scrollTop increases
     * @return {EScrollResult} full in case of a full rebuild or partial update
     */
    ARowRenderer.prototype.onScrolledVertically = function (scrollTop, clientHeight, isGoingDown) {
        var shift = this.options.viewportOversize;
        var shiftTop = Math.max(0, scrollTop - shift);
        var scrollResult = this.onScrolledImpl(shiftTop, clientHeight + shift + (scrollTop - shiftTop));
        for (var _i = 0, _a = this.mixins; _i < _a.length; _i++) {
            var mixin = _a[_i];
            mixin.onScrolled(isGoingDown, scrollResult);
        }
        return scrollResult;
    };
    ARowRenderer.prototype.shiftLast = function (current, currentDelta) {
        var b = this.options.batchSize;
        if (currentDelta >= b) {
            return current;
        }
        var total = this.context.numberOfRows;
        return Math.min(total - 1, current + (this.options.batchSize - currentDelta));
    };
    ARowRenderer.prototype.shiftFirst = function (current, currentFirstRow, currentDelta) {
        var _a;
        var b = this.options.batchSize;
        if (currentDelta >= b || current <= 0) {
            return { first: current, firstRowPos: currentFirstRow };
        }
        var first = Math.max(0, current - (this.options.batchSize - currentDelta));
        var _b = this.context, exceptionsLookup = _b.exceptionsLookup, defaultRowHeight = _b.defaultRowHeight;
        var firstRowPos = currentFirstRow;
        for (var i = first; i < current; i += 1) {
            firstRowPos -= (_a = exceptionsLookup.get(i)) !== null && _a !== void 0 ? _a : defaultRowHeight;
        }
        return { first: first, firstRowPos: firstRowPos };
    };
    ARowRenderer.prototype.onScrolledImpl = function (scrollTop, clientHeight) {
        var context = this.context;
        var _a = range(scrollTop, clientHeight, context.defaultRowHeight, context.exceptions, context.numberOfRows), first = _a.first, last = _a.last, firstRowPos = _a.firstRowPos;
        var visible = this.visible;
        visible.forcedFirst = first;
        visible.forcedLast = last;
        if (first - visible.first >= 0 && last - visible.last <= 0) {
            // nothing to do
            return EScrollResult.NONE;
        }
        var r = EScrollResult.SOME;
        var toRecycle;
        var toAdd;
        var toAddBottom = false;
        if (first > visible.last || last < visible.first) {
            // no overlap, clean and draw everything
            // console.log(`ff added: ${last - first + 1} removed: ${visibleLast - visibleFirst + 1} ${first}:${last} ${offset}`);
            // removeRows(visibleFirst, visibleLast);
            toRecycle = this.removeAll(false);
            toAdd = this.addAtBottom(first, last, false);
            toAddBottom = true;
            r = EScrollResult.ALL;
        }
        else if (first < visible.first) {
            // some first rows missing and some last rows to much
            // console.log(`up added: ${visibleFirst - first + 1} removed: ${visibleLast - last + 1} ${first}:${last} ${offset}`);
            var toRemove = visible.last - (last + 1);
            if (toRemove >= this.options.batchSize) {
                toRecycle = this.removeFromBottom(last + 1, visible.last, false);
            }
            else {
                last = visible.last;
            }
            var shift = this.shiftFirst(first, firstRowPos, visible.first - 1 - first);
            first = shift.first;
            firstRowPos = shift.firstRowPos;
            toAdd = this.addAtBeginning(first, visible.first - 1, false);
            toAddBottom = false;
            r = EScrollResult.SOME_TOP;
        }
        else {
            // console.log(`do added: ${last - visibleLast + 1} removed: ${first - visibleFirst + 1} ${first}:${last} ${offset}`);
            // some last rows missing and some first rows to much
            var toRemove = first - 1 - visible.first;
            if (toRemove >= this.options.batchSize) {
                toRecycle = this.removeFromBeginning(visible.first, first - 1, false);
            }
            else {
                first = visible.first;
                firstRowPos = this.visibleFirstRowPos;
            }
            last = this.shiftLast(last, last - visible.last + 1);
            toAdd = this.addAtBottom(visible.last + 1, last, false);
            toAddBottom = true;
            r = EScrollResult.SOME_BOTTOM;
        }
        visible.first = first;
        visible.last = last;
        this.updateOffset(firstRowPos);
        this.manipulate(toRecycle, toAdd, toAddBottom);
        return r;
    };
    ARowRenderer.prototype.manipulate = function (toRecycle, toAdd, bottom) {
        if (toRecycle) {
            for (var _i = 0, toRecycle_1 = toRecycle; _i < toRecycle_1.length; _i++) {
                var item = toRecycle_1[_i];
                item.remove();
                this.recycle(item);
            }
        }
        if (!toAdd) {
            return;
        }
        if (bottom) {
            this.body.appendChild(toAdd);
        }
        else {
            this.body.insertBefore(toAdd, this.body.firstChild);
        }
    };
    return ARowRenderer;
}());
export { ARowRenderer };
export default ARowRenderer;
export function setTransform(elem, x, y) {
    var text = "translate(".concat(x, "px, ").concat(y, "px)");
    var anyElem = elem;
    // eslint-disable-next-line no-underscore-dangle
    if (anyElem.__transform__ === text) {
        return;
    }
    // eslint-disable-next-line no-underscore-dangle
    anyElem.__transform__ = text;
    // eslint-disable-next-line no-param-reassign
    elem.style.transform = text;
}
//# sourceMappingURL=ARowRenderer.js.map