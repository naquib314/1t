/**
 * generic exception of a uniform space
 */
export interface IRowHeightException {
    /**
     * reference index
     */
    readonly index: number;
    /**
     * height of the element
     */
    readonly height: number;
    /**
     * starting y
     */
    readonly y: number;
    /**
     * ending y
     */
    readonly y2: number;
}
/**
 * similar to a map
 */
export interface IRowHeightExceptionLookup {
    keys(): IterableIterator<number>;
    get(index: number): number | undefined;
    has(index: number): boolean;
    readonly size: number;
}
/**
 * exception context for optimized non uniform height exceptions
 */
export interface IExceptionContext {
    /**
     * height exceptions as a list
     */
    readonly exceptions: IRowHeightException[];
    /**
     * lookup for the height of a given index, if not part of this map it has the default height
     */
    readonly exceptionsLookup: IRowHeightExceptionLookup;
    /**
     * number of rows
     */
    readonly numberOfRows: number;
    /**
     * default height of rows
     */
    readonly defaultRowHeight: number;
    /**
     * total height
     */
    readonly totalHeight: number;
    /**
     * padding between rows, however already included in all heights to have the precise numbers
     */
    readonly padding: (index: number) => number;
}
/**
 * creates a uniform exception context, i.e no exceptions all rows are of the same height
 * @param {number} numberOfRows
 * @param {number} currentRowHeight
 * @param {number} rowPadding padding between rows
 * @return {IExceptionContext}
 */
export declare function uniformContext(numberOfRows: number, rowHeight: number, rowPadding?: number): IExceptionContext;
/**
 * creates a non uniform context based on the given array like heights
 * @param rowHeights array like to get the heights
 * @param {number} defaultRowHeight if not given the most frequent value will be used
 * @param {number} rowPadding padding between rows
 * @return {IExceptionContext}
 */
export declare function nonUniformContext(rowHeights: {
    forEach: (callback: (height: number, index: number) => void) => void;
}, defaultRowHeight?: number, rowPadding?: number | ((index: number) => number)): IExceptionContext;
/**
 * creates a random context with the given constraints
 * @param {number} numberOfRows
 * @param {number} defaultRowHeight
 * @param {number} minRowHeight
 * @param {number} maxRowHeight
 * @param {number} ratio around ratio percent will get a non uniform height
 * @param {number} seed random seed
 * @return {IExceptionContext}
 */
export declare function randomContext(numberOfRows: number, defaultRowHeight: number, minRowHeight?: number, maxRowHeight?: number, ratio?: number, seed?: number): IExceptionContext;
export interface IVisibleRange {
    /**
     * first visible index
     */
    readonly first: number;
    /**
     * last visible index
     */
    readonly last: number;
    /**
     * position of the first visible row in pixel
     */
    readonly firstRowPos: number;
    /**
     * position of the last visible row including its size
     */
    readonly endPos: number;
}
/**
 * computes the visible range
 * @param {number} scrollTop top scrolling
 * @param {number} clientHeight visible height
 * @param {number} rowHeight height of a row by default
 * @param {IRowHeightException[]} heightExceptions exceptions of this default height
 * @param {number} numberOfRows the number of rows
 * @return {IVisibleRange} the computed visible range
 */
export declare function range(scrollTop: number, clientHeight: number, rowHeight: number, heightExceptions: IRowHeightException[], numberOfRows: number): IVisibleRange;
export declare function frozenDelta(current: number[], target: number[]): {
    added: number[];
    removed: number[];
    common: number;
};
export declare function updateFrozen(old: number[], columns: {
    frozen: boolean;
}[], first: number): {
    target: number[];
    added: number[];
    removed: number[];
};
//# sourceMappingURL=logic.d.ts.map