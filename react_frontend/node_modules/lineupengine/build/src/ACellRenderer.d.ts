import { IAbortAblePromise, IAsyncUpdate } from './abortAble';
import { IAnimationContext } from './animation';
import { ARowRenderer, IRowRendererOptions } from './ARowRenderer';
import { EScrollResult, IMixinClass } from './mixin';
import { GridStyleManager, IColumn } from './style';
import { ICellAdapterRenderContext, IVisibleColumns } from './table/internal/ACellAdapter';
export declare type ICellRenderContext<T extends IColumn> = ICellAdapterRenderContext<T>;
/**
 * a @see ARowRenderer which manages multiple columns per row
 */
export declare abstract class ACellRenderer<T extends IColumn> extends ARowRenderer {
    protected readonly root: HTMLElement;
    protected readonly style: GridStyleManager;
    private readonly cell;
    constructor(root: HTMLElement, htmlId: string, options?: Partial<IRowRendererOptions>);
    protected get idPrefix(): string;
    /**
     * get the header root element
     */
    protected get header(): HTMLElement;
    /**
     * get the header scrolling element, i.e its parent
     */
    protected get headerScroller(): HTMLElement;
    protected get visibleColumns(): IVisibleColumns;
    protected get visibleFirstColumnPos(): number;
    /**
     * add another column mixin
     * @param {IMixinClass} mixinClass mixing class to instantiate
     * @param options optional options
     */
    protected addColumnMixin(mixinClass: IMixinClass, options?: unknown): void;
    /**
     * initialized this renderer
     */
    protected init(): void;
    destroy(): void;
    /**
     * will be called when scrolled horizontally
     * @param {number} scrollLeft
     * @param {number} clientWidth
     * @param {boolean} isGoingRight
     * @returns {EScrollResult}
     */
    protected onScrolledHorizontally(scrollLeft: number, clientWidth: number, isGoingRight: boolean): EScrollResult;
    /**
     * the current render context, upon change `recreate` the whole table
     * @returns {ICellRenderContext}
     */
    protected abstract get context(): ICellRenderContext<T>;
    /**
     * create a new header node for the given column
     * @param {Document} document document to create nodes of
     * @param {T} column the column to create the header for
     * @returns {HTMLElement} the node representing the header
     */
    protected abstract createHeader(document: Document, column: T): HTMLElement | IAsyncUpdate<HTMLElement>;
    /**
     * updates the given header node with the given column
     * @param {HTMLElement} node node to update
     * @param {T} column the column to represents
     * @returns {HTMLElement | void} an optional new replacement node for the header
     */
    protected abstract updateHeader(node: HTMLElement, column: T): HTMLElement | IAsyncUpdate<HTMLElement> | void;
    /**
     * create a new cell node fo the given row index and column
     * @param {Document} document document the create nodes of
     * @param {number} index the current row index
     * @param {T} column the current column
     * @returns {HTMLElement} the node representing the cell
     */
    protected abstract createCell(document: Document, index: number, column: T): HTMLElement | IAsyncUpdate<HTMLElement>;
    /**
     * updates the given cell node with the given row index and column
     * @param {HTMLElement} node node to update
     * @param {number} index row index to use
     * @param {T} column column to use
     * @returns {HTMLElement | void} an optional new replacement node for the header
     */
    protected abstract updateCell(node: HTMLElement, index: number, column: T): HTMLElement | IAsyncUpdate<HTMLElement> | void;
    /**
     * trigger to update all headers
     */
    protected updateHeaders(): void;
    protected handleCellReady(item: HTMLElement, ready: IAbortAblePromise<void>, column?: number): HTMLElement;
    protected recycleCell(item: HTMLElement, column?: number): void;
    /**
     * triggers to update all column widths
     */
    protected updateColumnWidths(): void;
    protected updateSizer(firstRowPos: number): void;
    protected updateShifts(top: number, _left: number): void;
    /**
     * triggers to recreate the whole table
     * @param {IAnimationContext} ctx optional animation context
     */
    protected recreate(ctx?: IAnimationContext): void;
    protected clearPool(): void;
    protected createRow(node: HTMLElement, rowIndex: number): void;
    protected updateRow(node: HTMLElement, rowIndex: number): void;
}
export default ACellRenderer;
//# sourceMappingURL=ACellRenderer.d.ts.map