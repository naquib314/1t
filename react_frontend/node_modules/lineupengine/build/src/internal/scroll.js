export var defaultMode = 'animation'; // Boolean((<any>window).chrome) ? 'animation' : 0, // animation frame on chrome;
function dummy() {
    return {
        handler: [],
        prev: null,
        timer: -1,
    };
}
var ScrollHandler = /** @class */ (function () {
    function ScrollHandler(node) {
        // this.current = this.asInfo();
        var _this = this;
        this.node = node;
        this.sync = dummy();
        this.animation = dummy();
        this.numbers = new Map();
        this.handleAnimationImpl = function () {
            if (_this.animation.timer !== 1) {
                return;
            }
            _this.handle(_this.animation);
            _this.animation.timer = -1;
        };
        node.addEventListener('scroll', function () {
            // this.current = this.asInfo();
            // if (this.prev && (Math.abs(this.current.left - this.prev.left) + Math.abs(this.current.top - this.prev.top)) < 4) {
            //   return;
            // }
            // this.prev = this.current;
            if (_this.sync.handler.length > 0) {
                _this.handle(_this.sync);
            }
            _this.handleAnimation();
            _this.handleTimeouts();
        }, {
            passive: true,
        });
    }
    Object.defineProperty(ScrollHandler.prototype, "current", {
        // current: IScrollInfo;
        // private prev: IScrollInfo | null = null;
        get: function () {
            return this.asInfo();
        },
        enumerable: false,
        configurable: true
    });
    ScrollHandler.prototype.handle = function (handler) {
        var info = this.current;
        if (handler.prev && Math.abs(info.left - handler.prev.left) + Math.abs(info.top - handler.prev.top) < 4) {
            return;
        }
        // eslint-disable-next-line no-param-reassign
        handler.prev = info;
        for (var _i = 0, _a = handler.handler; _i < _a.length; _i++) {
            var s = _a[_i];
            s(info);
        }
    };
    ScrollHandler.prototype.handleAnimation = function () {
        if (this.animation.timer !== -1 || this.animation.handler.length === 0) {
            return;
        }
        this.animation.timer = 1;
        requestAnimationFrame(this.handleAnimationImpl);
    };
    ScrollHandler.prototype.handleTimeouts = function () {
        var _this = this;
        if (this.numbers.size === 0) {
            return;
        }
        this.numbers.forEach(function (handler, n) {
            if (handler.handler.length === 0) {
                return;
            }
            // eslint-disable-next-line no-param-reassign, no-restricted-globals
            handler.timer = self.setTimeout(function () {
                _this.handle(handler);
                // eslint-disable-next-line no-param-reassign
                handler.timer = -1;
            }, n);
        });
    };
    ScrollHandler.prototype.asInfo = function () {
        return {
            left: this.node.scrollLeft,
            top: this.node.scrollTop,
            width: this.node.clientWidth,
            height: this.node.clientHeight,
        };
    };
    ScrollHandler.prototype.push = function (mode, handler) {
        var _a;
        if (typeof mode === 'number') {
            var entry = (_a = this.numbers.get(mode)) !== null && _a !== void 0 ? _a : dummy();
            entry.handler.push(handler);
            this.numbers.set(mode, entry);
        }
        switch (mode) {
            case 'sync':
                this.sync.handler.push(handler);
                break;
            case 'animation':
                this.animation.handler.push(handler);
                break;
        }
    };
    ScrollHandler.prototype.remove = function (handler) {
        var test = [this.sync, this.animation].concat(Array.from(this.numbers.values()));
        return test.some(function (d) {
            var index = d.handler.indexOf(handler);
            if (index >= 0) {
                d.handler.splice(index, 1);
            }
            return index >= 0;
        });
    };
    ScrollHandler.prototype.isWaiting = function (mode) {
        var _a, _b;
        switch (mode) {
            case 'animation':
                return this.animation.timer >= 0;
            case 'sync':
                return false;
            default:
                return ((_b = (_a = this.numbers.get(mode)) === null || _a === void 0 ? void 0 : _a.timer) !== null && _b !== void 0 ? _b : -1) >= 0;
        }
    };
    return ScrollHandler;
}());
/**
 * @internal
 */
export function addScroll(scrollElement, mode, handler) {
    // hide in element to have just one real listener
    var c = scrollElement;
    if (!c.__le_scroller__) {
        c.__le_scroller__ = new ScrollHandler(scrollElement);
    }
    var s = c.__le_scroller__;
    s.push(mode, handler);
    return s.asInfo();
}
/**
 * @internal
 */
export function isScrollEventWaiting(scroller, mode) {
    var c = scroller;
    if (!c.__le_scroller__) {
        return false;
    }
    var s = c.__le_scroller__;
    return s.isWaiting(mode);
}
/**
 * @internal
 */
export function removeScroll(scroller, handler) {
    var c = scroller;
    if (c.__le_scroller__) {
        c.__le_scroller__.remove(handler);
    }
}
//# sourceMappingURL=scroll.js.map