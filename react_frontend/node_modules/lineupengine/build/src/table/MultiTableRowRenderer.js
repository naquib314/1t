var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { setTransform } from '../ARowRenderer';
import { addScroll, defaultMode } from '../internal';
import { GridStyleManager, tableCSSClasses, tableIds } from '../style';
import { cssClass, CSS_CLASS_BODY, CSS_CLASS_FOOTER, CSS_CLASS_HEADER, CSS_CLASS_MULTI, CSS_CLASS_TBODY, CSS_CLASS_THEAD, } from '../styles';
/**
 * manager of multiple columns separated by separators each an own row renderer
 */
var MultiTableRowRenderer = /** @class */ (function () {
    function MultiTableRowRenderer(node, htmlId, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.node = node;
        this.tableId = 0;
        this.sections = [];
        this.options = {
            columnPadding: 0,
            async: defaultMode,
            minScrollDelta: 30,
        };
        Object.assign(this.options, options);
        var cleanHTMLId = htmlId.startsWith('#') ? htmlId.slice(1) : htmlId;
        // eslint-disable-next-line no-param-reassign
        node.id = cleanHTMLId;
        // eslint-disable-next-line no-param-reassign
        node.innerHTML = "<header id=\"header-".concat(cleanHTMLId, "\" class=\"").concat(CSS_CLASS_HEADER, " ").concat(cssClass("header-".concat(cleanHTMLId)), "\">\n      <footer class=\"").concat(CSS_CLASS_FOOTER, " ").concat(cssClass("footer-".concat(cleanHTMLId)), "\">&nbsp;</footer>\n    </header>\n    <main id=\"body-").concat(cleanHTMLId, "\" class=\"").concat(CSS_CLASS_BODY, " ").concat(cssClass("body-".concat(cleanHTMLId)), "\">\n      <footer class=\"").concat(CSS_CLASS_FOOTER, "\">&nbsp;</footer>\n    </main>");
        node.classList.add(cssClass(), CSS_CLASS_MULTI, 'lineup-engine');
        this.style = new GridStyleManager(this.node, cleanHTMLId);
        var old = addScroll(this.main, this.options.async, function (act) {
            if (Math.abs(old.left - act.left) < _this.options.minScrollDelta &&
                Math.abs(old.width - act.width) < _this.options.minScrollDelta) {
                return;
            }
            var isGoingRight = act.left > old.left;
            old = act;
            _this.onScrolledHorizontally(act.left, act.width, isGoingRight);
        });
    }
    MultiTableRowRenderer.prototype.update = function () {
        var _this = this;
        this.onScrolledHorizontally(this.main.scrollLeft, this.main.clientWidth, false);
        var offset = 0;
        this.sections.forEach(function (s) {
            // eslint-disable-next-line no-param-reassign
            s.body.style.left = "".concat(offset, "px");
            // eslint-disable-next-line no-param-reassign
            s.header.style.left = "".concat(offset, "px");
            offset += s.width + _this.options.columnPadding;
        });
    };
    MultiTableRowRenderer.prototype.onScrolledHorizontally = function (scrollLeft, clientWidth, isGoingRight) {
        var _this = this;
        var offset = 0;
        var scrollEnd = scrollLeft + clientWidth;
        this.sections.forEach(function (s) {
            var end = offset + s.width;
            if (end < scrollLeft || offset > scrollEnd) {
                s.hide();
            }
            else {
                s.show(Math.max(0, scrollLeft - offset), Math.min(scrollEnd - offset, s.width), isGoingRight);
            }
            offset = end + _this.options.columnPadding;
        });
        this.updateOffset();
    };
    MultiTableRowRenderer.prototype.updateOffset = function () {
        var _this = this;
        var headerFooter = this.header.getElementsByTagName('footer')[0];
        var bodyFooter = this.main.getElementsByTagName('footer')[0];
        var maxHeight = this.sections.reduce(function (acc, d) { return Math.max(acc, d.height); }, 0);
        var total = this.sections.reduce(function (a, c) { return a + c.width + _this.options.columnPadding; }, 0);
        setTransform(headerFooter, total, 0);
        setTransform(bodyFooter, total, maxHeight);
    };
    MultiTableRowRenderer.prototype.destroy = function () {
        this.sections.forEach(function (d) { return d.destroy(); });
        this.node.remove();
    };
    Object.defineProperty(MultiTableRowRenderer.prototype, "doc", {
        get: function () {
            return this.node.ownerDocument;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiTableRowRenderer.prototype, "header", {
        get: function () {
            return this.node.getElementsByTagName('header')[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiTableRowRenderer.prototype, "main", {
        get: function () {
            return this.node.getElementsByTagName('main')[0];
        },
        enumerable: false,
        configurable: true
    });
    /**
     * push another table to this instance
     * @param {ITableFactory<T extends ITableSection>} factory factory for the table
     * @param extras additional arguments to provide for the factory
     * @returns {T} the table instance
     */
    MultiTableRowRenderer.prototype.pushTable = function (factory) {
        var extras = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            extras[_i - 1] = arguments[_i];
        }
        var header = this.doc.createElement('article');
        var body = this.doc.createElement('article');
        var tableId = "".concat(this.node.id, "T").concat(this.tableId);
        this.tableId += 1;
        var ids = tableIds(tableId);
        var cssClasses = tableCSSClasses(tableId);
        header.id = ids.thead;
        header.classList.add(CSS_CLASS_THEAD, cssClasses.thead);
        body.id = ids.tbody;
        body.classList.add(CSS_CLASS_TBODY, cssClasses.tbody);
        this.header.insertBefore(header, this.header.lastElementChild); // before the footer
        this.main.appendChild(body);
        var table = factory.call.apply(factory, __spreadArray([this, header, body, tableId, this.style], extras, false));
        table.init();
        this.sections.push(table);
        this.update();
        return table;
    };
    /**
     * push another separator to the manager
     * @param {ISeparatorFactory<T extends ITableSection>} factory the factory to create the separator
     * @param extras optional additional arguments
     * @returns {T} the new created separator
     */
    MultiTableRowRenderer.prototype.pushSeparator = function (factory) {
        var extras = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            extras[_i - 1] = arguments[_i];
        }
        var header = this.doc.createElement('section');
        var body = this.doc.createElement('section');
        header.classList.add(cssClass('header-separator'));
        body.classList.add(cssClass('separator'));
        this.header.insertBefore(header, this.header.lastElementChild); // before the footer
        this.main.appendChild(body);
        var separator = factory.call.apply(factory, __spreadArray([this, header, body, this.style], extras, false));
        separator.init();
        this.sections.push(separator);
        this.update();
        return separator;
    };
    /**
     * removes a given table section
     * @param {ITableSection} section section to remove
     * @returns {boolean} successful flag
     */
    MultiTableRowRenderer.prototype.remove = function (section) {
        var index = this.sections.indexOf(section);
        if (index < 0) {
            return false;
        }
        this.sections.splice(index, 1);
        section.destroy();
        this.update();
        return true;
    };
    MultiTableRowRenderer.prototype.clear = function () {
        this.sections.splice(0, this.sections.length).forEach(function (s) { return s.destroy(); });
        this.update();
    };
    /**
     * triggers and update because of a change in width of one or more table sections
     */
    MultiTableRowRenderer.prototype.widthChanged = function () {
        this.update();
    };
    return MultiTableRowRenderer;
}());
export default MultiTableRowRenderer;
//# sourceMappingURL=MultiTableRowRenderer.js.map