import { IAbortAblePromise, IAsyncUpdate } from '../abortAble';
import { IAnimationContext } from '../animation';
import { ARowRenderer, IRowRendererOptions } from '../ARowRenderer';
import { EScrollResult, IMixinClass } from '../mixin';
import { IColumn } from '../style';
import GridStyleManager from '../style/GridStyleManager';
import { ICellAdapterRenderContext, IVisibleColumns } from './internal/ACellAdapter';
import { ITableSection } from './MultiTableRowRenderer';
export declare type ITableCellRenderContext<T extends IColumn> = ICellAdapterRenderContext<T>;
/**
 * base class for a cell renderer as table section
 */
export declare abstract class ACellTableSection<T extends IColumn> extends ARowRenderer implements ITableSection {
    readonly header: HTMLElement;
    readonly body: HTMLElement;
    protected readonly tableId: string;
    protected readonly style: GridStyleManager;
    private readonly cell;
    constructor(header: HTMLElement, body: HTMLElement, tableId: string, style: GridStyleManager, options?: Partial<IRowRendererOptions>);
    protected addColumnMixin(mixinClass: IMixinClass, options?: unknown): void;
    protected get idPrefix(): string;
    abstract get id(): string;
    get width(): number;
    protected get visibleColumns(): IVisibleColumns;
    protected get visibleFirstColumnPos(): number;
    get height(): number;
    get hidden(): boolean;
    set hidden(value: boolean);
    protected updateSizer(firstRowPos: number): void;
    protected updateShifts(top: number, _left: number): void;
    /**
     * hook when the visibility changes
     * @param {boolean} _visible current visibility
     */
    protected onVisibilityChanged(_visible: boolean): void;
    hide(): void;
    show(scrollLeft: number, clientWidth: number, isGoingRight: boolean): void;
    init(): void;
    destroy(): void;
    protected onScrolledVertically(scrollTop: number, clientHeight: number, isGoingDown: boolean): EScrollResult;
    protected onScrolledHorizontally(scrollLeft: number, clientWidth: number, isGoingRight: boolean): EScrollResult;
    /**
     * the current render context, upon change `recreate` the whole table
     * @returns {ITableCellRenderContext}
     */
    protected abstract get context(): ITableCellRenderContext<T>;
    /**
     * create a new header node for the given column
     * @param {Document} document document to create nodes of
     * @param {T} column the column to create the header for
     * @returns {HTMLElement} the node representing the header
     */
    protected abstract createHeader(document: Document, column: T): HTMLElement | IAsyncUpdate<HTMLElement>;
    /**
     * updates the given header node with the given column
     * @param {HTMLElement} node node to update
     * @param {T} column the column to represents
     * @returns {HTMLElement | void} an optional new replacement node for the header
     */
    protected abstract updateHeader(node: HTMLElement, column: T): HTMLElement | IAsyncUpdate<HTMLElement> | void;
    /**
     * create a new cell node fo the given row index and column
     * @param {Document} document document the create nodes of
     * @param {number} index the current row index
     * @param {T} column the current column
     * @returns {HTMLElement} the node representing the cell
     */
    protected abstract createCell(document: Document, index: number, column: T): HTMLElement | IAsyncUpdate<HTMLElement>;
    /**
     * updates the given cell node with the given row index and column
     * @param {HTMLElement} node node to update
     * @param {number} index row index to use
     * @param {T} column column to use
     * @returns {HTMLElement | void} an optional new replacement node for the header
     */
    protected abstract updateCell(node: HTMLElement, index: number, column: T): HTMLElement | IAsyncUpdate<HTMLElement> | void;
    /**
     * triggers updating the header
     */
    protected updateHeaders(): void;
    protected handleCellReady(item: HTMLElement, ready: IAbortAblePromise<void>, column?: number): HTMLElement;
    protected recycleCell(item: HTMLElement, column?: number): void;
    /**
     * trigger an update all all column widths
     */
    protected updateColumnWidths(): void;
    protected recreate(ctx?: IAnimationContext): void;
    protected clearPool(): void;
    protected createRow(node: HTMLElement, rowIndex: number): void;
    protected updateRow(node: HTMLElement, rowIndex: number): void;
}
export default ACellTableSection;
//# sourceMappingURL=ACellTableSection.d.ts.map