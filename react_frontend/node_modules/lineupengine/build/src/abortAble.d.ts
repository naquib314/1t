export declare function isPromiseLike(p: PromiseLike<unknown> | unknown): p is PromiseLike<unknown>;
/**
 * a promise like object that has an abort method
 */
export interface IAbortAblePromiseBase<T> extends PromiseLike<T> {
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | undefined | null): IAbortAblePromiseBase<TResult1 | TResult2>;
    /**
     * abort the promise when possible
     */
    abort(): void;
    /**
     * whether this promise was aborted
     */
    isAborted(): boolean;
}
/**
 * a promise like object that has an abort method and return the ABORTED symbol in case it was
 */
export declare type IAbortAblePromise<T> = IAbortAblePromiseBase<T | symbol>;
export declare type IAAP<T> = IAbortAblePromise<T>;
/**
 * an update result with an item and a promise when the update has been done
 */
export interface IAsyncUpdate<T> {
    item: T;
    ready: IAbortAblePromise<void>;
}
/**
 * the symbol returned when the promise was aborted
 */
export declare const ABORTED: unique symbol;
/**
 * abort able Promise wrapper, returns a promise which can be aborted, and trying to avoid executing therefore the wrapped promise
 * @param {Promise<T>} loader
 * @returns {any}
 */
export default function abortAble<T>(loader: PromiseLike<T>): IAAP<T>;
export declare function abortAbleFetch(input: RequestInfo, init?: RequestInit): IAAP<Response>;
export declare function abortAbleAll<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [
    T1 | IAAP<T1>,
    T2 | IAAP<T2>,
    T3 | IAAP<T3>,
    T4 | IAAP<T4>,
    T5 | IAAP<T5>,
    T6 | IAAP<T6>,
    T7 | IAAP<T7>,
    T8 | IAAP<T8>,
    T9 | IAAP<T9>,
    T10 | IAAP<T10>
]): IAAP<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
export declare function abortAbleAll<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [
    T1 | IAAP<T1>,
    T2 | IAAP<T2>,
    T3 | IAAP<T3>,
    T4 | IAAP<T4>,
    T5 | IAAP<T5>,
    T6 | IAAP<T6>,
    T7 | IAAP<T7>,
    T8 | IAAP<T8>,
    T9 | IAAP<T9>
]): IAAP<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
export declare function abortAbleAll<T1, T2, T3, T4, T5, T6, T7, T8>(values: [
    T1 | IAAP<T1>,
    T2 | IAAP<T2>,
    T3 | IAAP<T3>,
    T4 | IAAP<T4>,
    T5 | IAAP<T5>,
    T6 | IAAP<T6>,
    T7 | IAAP<T7>,
    T8 | IAAP<T8>
]): IAAP<[T1, T2, T3, T4, T5, T6, T7, T8]>;
export declare function abortAbleAll<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | IAAP<T1>, T2 | IAAP<T2>, T3 | IAAP<T3>, T4 | IAAP<T4>, T5 | IAAP<T5>, T6 | IAAP<T6>, T7 | IAAP<T7>]): IAAP<[T1, T2, T3, T4, T5, T6, T7]>;
export declare function abortAbleAll<T1, T2, T3, T4, T5, T6>(values: [T1 | IAAP<T1>, T2 | IAAP<T2>, T3 | IAAP<T3>, T4 | IAAP<T4>, T5 | IAAP<T5>, T6 | IAAP<T6>]): IAAP<[T1, T2, T3, T4, T5, T6]>;
export declare function abortAbleAll<T1, T2, T3, T4, T5>(values: [T1 | IAAP<T1>, T2 | IAAP<T2>, T3 | IAAP<T3>, T4 | IAAP<T4>, T5 | IAAP<T5>]): IAAP<[T1, T2, T3, T4, T5]>;
export declare function abortAbleAll<T1, T2, T3, T4>(values: [T1 | IAAP<T1>, T2 | IAAP<T2>, T3 | IAAP<T3>, T4 | IAAP<T4>]): IAAP<[T1, T2, T3, T4]>;
export declare function abortAbleAll<T1, T2, T3>(values: [T1 | IAAP<T1>, T2 | IAAP<T2>, T3 | IAAP<T3>]): IAAP<[T1, T2, T3]>;
export declare function abortAbleAll<T1, T2>(values: [T1 | IAAP<T1>, T2 | IAAP<T2>]): IAAP<[T1, T2]>;
export declare function abortAbleAll<T>(values: (T | IAAP<T>)[]): IAAP<T[]>;
/**
 * checked whether the given argument is an abortable Promise
 * @param {IAbortAblePromise<any> | any} candidate
 * @returns {boolean}
 */
export declare function isAbortAble<T = unknown>(candidate: IAbortAblePromise<T> | T): candidate is IAbortAblePromise<T>;
export declare function isAsyncUpdate<T>(update: T | void | undefined | null | IAsyncUpdate<T>): update is IAsyncUpdate<T>;
/**
 * similar to Promise.resolve
 */
export declare function abortAbleResolveNow<T>(value: T): IAAP<T>;
//# sourceMappingURL=abortAble.d.ts.map