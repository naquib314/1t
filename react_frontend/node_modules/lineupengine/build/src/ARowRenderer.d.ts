import { IAbortAblePromise } from './abortAble';
import { IAnimationContext } from './animation';
import { IDelayedMode, IScrollInfo } from './internal';
import { IExceptionContext } from './logic';
import { EScrollResult, IMixinClass } from './mixin';
export declare type IRowRenderContext = IExceptionContext;
export declare function isLoadingCell(node: HTMLElement): boolean;
export interface IRowRendererOptions {
    /**
     * async update on scrolling
     * animation -> use requestAnimationFrame
     * sync -> execute within scroll listener
     * {number} -> execute within this delay using setTimeout
     * @default is chrome ? animation else 0
     */
    async: IDelayedMode;
    /**
     * minimal number of pixel the scrollbars has to move
     * @default 10
     */
    minScrollDelta: number;
    /**
     * min number of rows that should be added or removed
     * @default 10
     */
    batchSize: number;
    /**
     * number of pixels the viewport is virtually larger
     * @default 200
     */
    viewportOversize: number;
    /**
     * class of mixins to use for optimized rendering
     */
    mixins: IMixinClass[];
    /**
     * add the scrolling hint class while scrolling to give a user feedback
     */
    scrollingHint: boolean;
    /**
     * whether background striping should be enabled
     */
    striped: boolean;
}
/**
 * base class for creating a scalable table renderer based on rows
 */
export declare abstract class ARowRenderer {
    protected readonly body: HTMLElement;
    private readonly pool;
    private readonly loadingPool;
    private readonly loading;
    private readonly fragment;
    /**
     * currently visible slice
     */
    protected readonly visible: {
        first: number;
        forcedFirst: number;
        last: number;
        forcedLast: number;
    };
    /**
     * position of the first visible row in pixel
     * @type {number}
     */
    protected visibleFirstRowPos: number;
    private readonly adapter;
    private readonly mixins;
    private scrollListener;
    protected lastScrollInfo: IScrollInfo | null;
    private abortAnimation;
    protected readonly options: Readonly<IRowRendererOptions>;
    constructor(body: HTMLElement, options?: Partial<IRowRendererOptions>);
    protected abstract get idPrefix(): string;
    /**
     * register another mixin to this renderer
     * @param {IMixinClass} MixinClass the mixin class to instantiate
     * @param options optional constructor options
     */
    protected addMixin(MixinClass: IMixinClass, options?: unknown): void;
    private createAdapter;
    /**
     * get the scrolling container i.e. parent of the body element
     * @returns {HTMLElement}
     */
    protected get bodyScroller(): HTMLElement;
    protected get bodySizer(): HTMLElement;
    /**
     * the current render context, upon change `recreate` the whole table
     * @returns {IRowRenderContext}
     */
    protected abstract get context(): IRowRenderContext;
    /**
     * creates a new row
     * @param {HTMLElement} node the node of the row
     * @param {number} index the row index
     * @returns {IAbortAblePromise<void> | void} either an abortable or nothing
     */
    protected abstract createRow(node: HTMLElement, index: number): IAbortAblePromise<void> | void;
    /**
     * updates a row
     * @param {HTMLElement} node the node of the row
     * @param {number} index the row index
     * @returns {IAbortAblePromise<void> | void} either an abortable or nothing
     */
    protected abstract updateRow(node: HTMLElement, index: number): IAbortAblePromise<void> | void;
    /**
     * initializes the table and register the onscroll listener
     * @returns {void} nothing
     */
    protected init(): void;
    /**
     * destroys this renderer and unregisters all event listeners
     */
    destroy(): void;
    private static cleanUp;
    private select;
    private selectProxy;
    private recycle;
    private proxy;
    private create;
    private removeAll;
    /**
     * triggers and visual update of all visible rows
     */
    protected update(): void;
    /**
     * utility to execute a function for each visible row
     * @param {(row: HTMLElement, rowIndex: number) => void} callback callback to execute
     * @param {boolean} inPlace whether the DOM changes should be performed in place instead of in a fragment
     */
    protected forEachRow(callback: (row: HTMLElement, rowIndex: number) => void, inPlace?: boolean): void;
    private removeFromBeginning;
    private removeFromBottom;
    private remove;
    private addAtBeginning;
    private addAtBottom;
    protected updateOffset(firstRowPos: number): void;
    protected updateSizer(firstRowPos: number): void;
    /**
     * removes all rows and recreates the table
     * @param {IAnimationContext} ctx optional animation context to create a transition between the previous and the current tables
     * @returns {void} nothing
     */
    protected recreate(ctx?: IAnimationContext): void;
    private recreatePure;
    private recreateAnimated;
    private animate;
    /**
     * clears the row pool used for faster creation
     */
    protected clearPool(): void;
    /**
     * triggers a revalidation of the current scrolling offset
     */
    protected revalidate(): void;
    /**
     * scrolling vertically
     * @param {number} scrollTop top scrolling
     * @param {number} clientHeight visible height
     * @param {boolean} isGoingDown hint whether the scrollTop increases
     * @return {EScrollResult} full in case of a full rebuild or partial update
     */
    protected onScrolledVertically(scrollTop: number, clientHeight: number, isGoingDown: boolean): EScrollResult;
    private shiftLast;
    private shiftFirst;
    private onScrolledImpl;
    private manipulate;
}
export default ARowRenderer;
export declare function setTransform(elem: HTMLElement, x: number | string, y: number | string): void;
//# sourceMappingURL=ARowRenderer.d.ts.map