var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { createGetHeight, flattenGroupedChildren, getCurrentIndex, sum, } from './util';
import * as React from 'react';
import { VariableSizeList as List } from 'react-window';
function MenuList(props) {
    var children = React.useMemo(function () {
        var children = React.Children.toArray(props.children);
        var head = children[0] || {};
        if (React.isValidElement(head)) {
            var _a = head.props, _b = _a === void 0 ? {} : _a, _c = _b.data, _d = _c === void 0 ? {} : _c, _e = _d.options, options = _e === void 0 ? [] : _e;
            var groupedChildrenLength = options.length;
            var isGrouped = groupedChildrenLength > 0;
            var flattenedChildren = isGrouped && flattenGroupedChildren(children);
            return isGrouped
                ? flattenedChildren
                : children;
        }
        else {
            return [];
        }
    }, [props.children]);
    var getStyles = props.getStyles;
    var groupHeadingStyles = getStyles('groupHeading', props);
    var loadingMsgStyles = getStyles('loadingMessage', props);
    var noOptionsMsgStyles = getStyles('noOptionsMessage', props);
    var optionStyles = getStyles('option', props);
    var getHeight = createGetHeight({
        groupHeadingStyles: groupHeadingStyles,
        noOptionsMsgStyles: noOptionsMsgStyles,
        optionStyles: optionStyles,
        loadingMsgStyles: loadingMsgStyles,
    });
    var heights = React.useMemo(function () { return children.map(getHeight); }, [children]);
    var currentIndex = React.useMemo(function () { return getCurrentIndex(children); }, [children]);
    var itemCount = children.length;
    // calc menu height
    var _a = getStyles('menuList', props), maxHeight = _a.maxHeight, _b = _a.paddingBottom, paddingBottom = _b === void 0 ? 0 : _b, _c = _a.paddingTop, paddingTop = _c === void 0 ? 0 : _c, menuListStyle = __rest(_a, ["maxHeight", "paddingBottom", "paddingTop"]);
    var totalHeight = React.useMemo(function () { return heights.reduce(sum, 0); }, [heights]);
    var totalMenuHeight = totalHeight + paddingBottom + paddingTop;
    var menuHeight = Math.min(maxHeight, totalMenuHeight);
    var estimatedItemSize = Math.floor(totalHeight / itemCount);
    var innerRef = props.innerRef, selectProps = props.selectProps;
    var _d = selectProps || {}, classNamePrefix = _d.classNamePrefix, isMulti = _d.isMulti;
    var list = React.useRef(null);
    var measuredHeights = React.useRef({});
    React.useEffect(function () {
        measuredHeights.current = {};
    }, [props.children]);
    // method to pass to inner item to set this items outer height
    var setMeasuredHeight = function (_a) {
        var _b;
        var index = _a.index, measuredHeight = _a.measuredHeight;
        if (measuredHeights.current[index] && measuredHeights.current[index] === measuredHeight) {
            return;
        }
        measuredHeights.current = __assign(__assign({}, measuredHeights.current), (_b = {}, _b[index] = measuredHeight, _b));
        // this forces the list to rerender items after the item positions resizing
        if (list.current) {
            list.current.resetAfterIndex(index);
        }
    };
    React.useEffect(function () {
        /**
         * enables scrolling on key down arrow
         */
        if (currentIndex >= 0 && list.current !== null) {
            list.current.scrollToItem(currentIndex);
        }
    }, [currentIndex, children, list]);
    return (React.createElement(List, { className: classNamePrefix ? classNamePrefix + "__menu-list" + (isMulti ? " " + classNamePrefix + "__menu-list--is-multi" : '') : '', style: menuListStyle, ref: list, outerRef: innerRef, estimatedItemSize: estimatedItemSize, innerElementType: React.forwardRef(function (_a, ref) {
            var style = _a.style, rest = __rest(_a, ["style"]);
            return (React.createElement("div", __assign({ ref: ref, style: __assign(__assign({}, style), { height: parseFloat(style.height) + paddingBottom + paddingTop + "px" }) }, rest)));
        }), height: menuHeight, width: "100%", itemCount: itemCount, itemData: children, itemSize: function (index) { return measuredHeights.current[index] || heights[index]; } }, function (_a) {
        var data = _a.data, index = _a.index, style = _a.style;
        return (React.createElement("div", { style: __assign(__assign({}, style), { top: parseFloat(style.top.toString()) + paddingTop + "px" }) },
            React.createElement(MenuItem, { data: data[index], index: index, setMeasuredHeight: setMeasuredHeight, height: heights[index] })));
    }));
}
function MenuItem(_a) {
    var data = _a.data, index = _a.index, setMeasuredHeight = _a.setMeasuredHeight, height = _a.height;
    var ref = React.useRef(null);
    // using useLayoutEffect prevents bounciness of options of re-renders
    React.useLayoutEffect(function () {
        if (ref.current) {
            var measuredHeight = ref.current.getBoundingClientRect().height;
            setMeasuredHeight({ index: index, measuredHeight: measuredHeight });
        }
    }, [ref.current]);
    return (React.createElement("div", { key: "option-" + index, ref: ref }, data));
}
export default MenuList;
//# sourceMappingURL=MenuList.js.map