/**
 * utility class for optimized row context access
 */
var KeyFinder = /** @class */ (function () {
    /**
     * constructor for fast key based row access
     * @param {IExceptionContext} context context to use
     * @param {(rowIndex: number) => string} key key function
     */
    function KeyFinder(context, key) {
        var _this = this;
        this.context = context;
        this.key = key;
        this.cache = [];
        this.lastFilled = 0;
        this.key2index = new Map();
        this.context.exceptions.forEach(function (e) {
            _this.cache[e.index] = e.y;
            _this.key2index.set(key(e.index), e.index);
        });
    }
    KeyFinder.prototype.findValidStart = function (before) {
        for (var i = before - 1; i >= 0; i -= 1) {
            if (this.cache[i] !== undefined) {
                return i;
            }
        }
        return -1;
    };
    /**
     * returns the position of the given given or -1 if not found
     * @param {string} key
     */
    KeyFinder.prototype.posByKey = function (key) {
        var index = this.key2index.get(key);
        if (index != null) {
            return { index: index, pos: this.pos(index) };
        }
        return this.fillCacheTillKey(key);
    };
    /**
     * returns the position of the given index
     * @param {number} index index to look for
     */
    KeyFinder.prototype.pos = function (index) {
        if (this.context.exceptions.length === 0) {
            // fast pass
            return index * this.context.defaultRowHeight;
        }
        var cached = this.cache[index];
        if (cached !== undefined) {
            return cached;
        }
        // need to compute it
        // find the starting point where to start counting
        var start = this.findValidStart(index);
        if (start < 0) {
            this.fillCache(0, index, 0);
        }
        else {
            this.fillCache(start + 1, index, this.cache[start] + this.heightOf(start));
        }
        return this.cache[index];
    };
    KeyFinder.prototype.fillCache = function (first, last, offset, callback) {
        if (last <= this.lastFilled) {
            // everything already there
            if (!callback) {
                return;
            }
            for (var i = first; i <= last; i += 1) {
                callback(i, this.key(i), this.cache[i]);
            }
            return;
        }
        var pos = offset;
        for (var i = first; i <= last; i += 1) {
            this.cache[i] = pos;
            var key = this.key(i);
            this.key2index.set(key, i);
            if (callback) {
                callback(i, key, pos);
            }
            pos += this.heightOf(i);
        }
    };
    /**
     * returns the height of the row identified by index
     * @param {number} index
     */
    KeyFinder.prototype.heightOf = function (index) {
        var _a;
        var lookup = this.context.exceptionsLookup;
        return (_a = lookup.get(index)) !== null && _a !== void 0 ? _a : this.context.defaultRowHeight;
    };
    KeyFinder.prototype.exceptionHeightOf = function (index, returnDefault) {
        if (returnDefault === void 0) { returnDefault = false; }
        var padding = this.context.padding(index);
        var lookup = this.context.exceptionsLookup;
        var entry = lookup.get(index);
        if (entry != null) {
            return entry - padding;
        }
        return returnDefault ? this.context.defaultRowHeight - padding : null;
    };
    /**
     * padding of the given index
     * @param {number} index
     * @returns {number}
     */
    KeyFinder.prototype.padding = function (index) {
        return this.context.padding(index);
    };
    KeyFinder.prototype.fillCacheTillKey = function (target) {
        var pos = 0;
        for (var i = this.lastFilled; i < this.context.numberOfRows; i += 1, this.lastFilled += 1) {
            var c = this.cache[i];
            if (c !== undefined) {
                pos = c + this.heightOf(i);
                continue;
            }
            // new one fill up
            var key = this.key(i);
            this.cache[i] = pos;
            this.key2index.set(key, i);
            if (key === target) {
                return { index: i, pos: pos };
            }
            pos += this.heightOf(i);
        }
        return { index: -1, pos: -1 };
    };
    /**
     * computes the positions and keys for a range of given indices
     * @param {number} first first row index
     * @param {number} last last row index
     * @param {number} offset pos offset for the first row index
     * @param {(index: number, key: string, pos: number) => void} callback callback for each identified index
     */
    KeyFinder.prototype.positions = function (first, last, offset, callback) {
        this.fillCache(first, last, offset, callback);
    };
    return KeyFinder;
}());
export default KeyFinder;
//# sourceMappingURL=KeyFinder.js.map